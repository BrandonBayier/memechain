#include "./http_api.h"
#include "./rpc_tx.h"
#include <netdb.h>
#include <dirent.h>
#include <sys/sysinfo.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <sys/types.h>

#include <algorithm>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <chrono>
#include <cctype>
#include <ctime>
#include <exception>
#include <functional>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <map>
#include <memory>
#include <regex>
#include <sstream>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "utils/base64.h"
#include "api/rpc_error.h"
#include "api/interface/rpc_tx.h"
#include <boost/math/constants/constants.hpp>
#include <boost/multiprecision/cpp_bin_float.hpp>
#include <boost/numeric/conversion/cast.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/multiprecision/cpp_int.hpp>
#include "ca/ca.h"
#include "ca/advanced_menu.h"
#include "ca/global.h"
#include "ca/transaction.h"
#include "ca/txhelper.h"
#include "common/global.h"
#include "db/cache.h"
#include "db/db_api.h"
#include "interface.pb.h"
#include "logging.h"
#include "utils/account_manager.h"
#include "utils/magic_singleton.h"
#include "utils/tmp_log.h"
#include "net/test.hpp"
#include "ca/test.h"
#include <utils/contract_utils.h>
#include <google/protobuf/util/json_util.h>
#include "google/protobuf/stubs/status.h"
#include "include/scope_guard.h"
#include "net/interface.h"
#include "net/global.h"
#include "net/httplib.h"
#include "net/api.h"
#include "net/peer_node.h"
#include "utils/json.hpp"
#include "utils/string_util.h"
#include "net/unregister_node.h"
#include "ca/algorithm.h"
#include "./rpc_tx.h"
#include "block.pb.h"
#include "ca_protomsg.pb.h"
#include "transaction.pb.h"
#include "utils/envelop.h"
#include "ca/interface.h"
#include "ca/vrf_consensus.h"
#include "rpc_create_transaction.h"
#include "ca/block_helper.h"
#include "common/global_data.h"

std::string MeMeChainLogo = "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');";
#define VALIDATE_JSON_REQUEST_PARSING                                             \
    std::string ParseRet = req_t._parseFromJson(req.body);            \
    if (ParseRet != "OK")                                            \
    {                                                               \
        errorL("bad error parse fail");                              \
        ack_t.code = 9090;                                          \
        ack_t.message = Sutil::Format("parse fail:%s", ParseRet);     \
        res.set_content(ack_t._parseToString(), "application/json"); \
        return;                                                     \
    }

#define CHECK_VALUE(value)\
        std::regex pattern("(^[1-9]\\d*\\.\\d+$|^0\\.\\d+$|^[1-9]\\d*$|^0$)");\
        if (!std::regex_match(value, pattern))\
        {\
            ack_t.code=-3004;\
            ack_t.message=Sutil::Format("input value error:",value);\
            res.set_content(ack_t._parseToString(), "application/json");\
            return;\
        }


// base64 picture
extern std::string MEMECHAIN_LOGO_BASE64 = "data:image/png;base64,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";

void InitializeHttpCallbacks() {
    HttpServer::RegisterCallback("/", _ApiJsonRpc);
    HttpServer::RegisterCallback("/GetPublicIp", _GetRequesterIP);
    HttpServer::RegisterCallback("/GetTxInfo", getTxInfo);
    HttpServer::RegisterCallback("/GetUndelegatingUtxo", _GetUndelegatingUtxo);
    HttpServer::RegisterCallback("/GetStakingUtxo", _GetStakeUtxo);
    HttpServer::RegisterCallback("/GetLockUtxo",_GetLockUtxo);
    HttpServer::RegisterCallback("/GetAllAssetType",_ApiGetAssetType);
    HttpServer::RegisterCallback("/GetAssetTypeInfo",_ApiGetAssetTypeInfo);
    HttpServer::RegisterCallback("/GetVoteAddrs",_ApiGetVoteAddrsByHash);
    HttpServer::RegisterCallback("/GetVoteTxHash",_ApiGetVoteTxHashByAssetType);

    HttpServer::RegisterCallback("/CreateTransaction", _GetTransaction);
    HttpServer::RegisterCallback("/CreateStakingTransaction", _GetStake);
    HttpServer::RegisterCallback("/CreateUnstakingTransaction", _GetUnstake);
    HttpServer::RegisterCallback("/CreateDelegatingTransaction", _GetDelegating);
    HttpServer::RegisterCallback("/CreateUndelegatingTransaction", _GetUndelegating);
    HttpServer::RegisterCallback("/CreateBonusTransaction", _GetBonus);
    HttpServer::RegisterCallback("/CreateCallContractTransaction", _CallContract);
    HttpServer::RegisterCallback("/CreateDeployContractTransaction", _DeployContract);
    HttpServer::RegisterCallback("/SendMessage", _ApiSendMessage);
    HttpServer::RegisterCallback("/SendContractMessage", handleSendContractMessage);
    HttpServer::RegisterCallback("/ConfirmTransaction",_ConfirmTransaction);
    HttpServer::RegisterCallback("/CreateLockTransaction", _GetLock); 
    HttpServer::RegisterCallback("/CreateUnLockTransaction",_GetUnLock);
    HttpServer::RegisterCallback("/CreateProposalTransaction", _GetProposal);
    HttpServer::RegisterCallback("/CreateRevokeProposalTransaction",_GetRevokeProposal);
    HttpServer::RegisterCallback("/CreateVoteTransaction", _GetVote);
    HttpServer::RegisterCallback("/CreateFundTransaction", _GetFund);

    HttpServer::RegisterCallback("/GetYieldInfo", _ApiGetYieldInfo);
    HttpServer::RegisterCallback("/GetAllStakeNodeList",_GetAllStakeNodes);
    HttpServer::RegisterCallback("/GetBonusInfo",_ApiGetAllBonusInfo);
    HttpServer::RegisterCallback("/GetBlockHeight",_GetBlockHeight);
    HttpServer::RegisterCallback("/GetVersion", _GetVersion);
    HttpServer::RegisterCallback("/GetBalance", _GetBalance);
    HttpServer::RegisterCallback("/GetBlockTransactionCountByHash", _GetBlockTransactionCountByHash);
    HttpServer::RegisterCallback("/GetAccounts", _GetAccounts);
    HttpServer::RegisterCallback("/GetChainId", _GetChainId);
    HttpServer::RegisterCallback("/GetNodeList", _GetPeerList);
    HttpServer::RegisterCallback("/GetAddrType", _GetAddrType);
    HttpServer::RegisterCallback("/GetBonusAddrByDelegatingAddr", _GetBonusAddrByDelegatingAddr);

    HttpServer::RegisterCallback("/GetTransactionByHash", getTransactionInfo);
    HttpServer::RegisterCallback("/GetBlockByTransactionHash", RetrieveBlockByTxHash);
    HttpServer::RegisterCallback("/GetBlockByHash", _ApiGetBlockByHash);
    HttpServer::RegisterCallback("/GetBlockByHeight", _ApiGetBlockByHeight);
    HttpServer::RegisterCallback("/GetDelegatingAddrsByBonusAddr", fetch_delegate_info_request);

    HttpServer::RegisterCallback("/block", print_block_info);
    HttpServer::RegisterCallback("/get_block", _ApiGetBlock);
    HttpServer::RegisterCallback("/pub", _ApiPub);
    HttpServer::RegisterCallback("/account", _ApiAccount);
    HttpServer::RegisterCallback("/Node",_ApiNode);
    HttpServer::RegisterCallback("/ShowVRFInfo", _ShowValidatedVRFs);
    HttpServer::RegisterCallback("/ShowNewVRFInfo", _ShowNewValidatedVRFs);
    HttpServer::RegisterCallback("/printCalcHash", _ApiPrintCalc1000SumHash);
    HttpServer::RegisterCallback("/printhundredhash", _ApiPrintHundredSumHash);
    HttpServer::RegisterCallback("/printblock", _ApiPrintAllBlocks);
    HttpServer::RegisterCallback("/SystemInfo", _GetAllSystemInfo);

    //vote ===========================================
    HttpServer::RegisterCallback("/printVoteInfo", _ApiPrintVoteInfo);
    HttpServer::RegisterCallback("/printLockAddrs", _ApiPrintLockAddrs);
    HttpServer::RegisterCallback("/printProposalInfoByHash", _ApiPrintProposalInfo);
    HttpServer::RegisterCallback("/printAvailableAssetType", _ApiPrintAvailableAssetType);
    HttpServer::RegisterCallback("/printAsseTypeByContractAddr", _ApiGetAsseTypeByContractAddr);  
    //===================================================
    HttpServer::Start();
}


void _ApiJsonRpc(const Request &req, Response &res) 
{
    nlohmann::json ret;
    ret["jsonrpc"] = "2.0";
    try {
        auto json = nlohmann::json::parse(req.body);

        std::string method = json["method"];

        auto p = HttpServer::rpcCbs.find(method);
        if (p == HttpServer::rpcCbs.end()) 
        {
            ret["error"]["code"] = -32601;
            ret["error"]["message"] = "Method not found";
            ret["id"] = "";
        } 
        else 
        {
            auto params = json["params"];
            ret = HttpServer::rpcCbs[method](params);
            try {
                ret["id"] = json["id"].get<int>();
            } 
            catch (const std::exception &e) 
            {
                ret["id"] = json["id"].get<std::string>();
            }
            ret["jsonrpc"] = "2.0";
        }
    } 
    catch (const std::exception &e) 
    {
        ret["error"]["code"] = -32700;
        ret["error"]["message"] = "Internal error";
        ret["id"] = "";
    }
    res.set_content(ret.dump(4), "application/json");
}


void getTxInfo(const Request &req, Response &res) 
{
    
    txRequest req_t;
    get_tx_info_ack ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "getTxInfo";
    DBReader dbReader;
    std::string BlockHash;
    std::string strHeader;
    unsigned int BlockHeight;
    if (DBStatus::DB_SUCCESS !=
        dbReader.GetTransactionByHash(req_t.txhash, strHeader)) 
    {
        ack_t.code = -2;
        ack_t.message = "txhash error";
        
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    if (DBStatus::DB_SUCCESS !=
        dbReader.blockHashByTxHash(req_t.txhash, BlockHash)) 
    {
        ack_t.code = -3;
        ack_t.message = "Block error";
        
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    if (DBStatus::DB_SUCCESS !=
        dbReader.QueryHeightFromHash(BlockHash, BlockHeight)) {
        ack_t.code = -4;
        ack_t.message = "Block error";

        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    CTransaction tx;
    if (!tx.ParseFromString(strHeader)) {
        ack_t.code = -5;
        ack_t.message = "tx ParseFromString error";
        
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    ack_t.code = 0;
    ack_t.message = "success";
    ack_t.tx = SerializeTransaction(tx);
    ack_t.blockhash = BlockHash;
    ack_t.blockheight = BlockHeight;
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetStake(const Request &req, Response &res) 
{
    getStakeReq req_t;
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateStakingTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);

    CHECK_VALUE(req_t.stakeAmount);
    uint64_t stake_amount =
        (std::stod(req_t.stakeAmount) + global::ca::kFixDoubleMinPrecision) *
        global::ca::kDecimalNum;
    int32_t stakeType = std::stoll(req_t.StakeType);

    std::regex bonus("^(5|6|7|8|9|1[0-9]|20)$"); // 5 - 20 
    if(!std::regex_match(req_t.commissionRate,bonus))
    {
        ack_t.code=-1;
        ack_t.message = "input pumping percentage error:" + req_t.commissionRate;
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    double commissionRate = std::stod(req_t.commissionRate) / 100;

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    std::pair<std::string,std::string> gastrade = req_t.gastrade ;
    gastrade.first = remove0xPrefix(gastrade.first);
    gastrade.second = remove0xPrefix(gastrade.second);
    bool isGasTrade = req_t.isGasTrade ; 
    

    CreateStakeTransaction(
        fromAddr, stake_amount, stakeType,gastrade,isGasTrade,&ack_t, commissionRate, isFindUtxoFlag, encodedInfo);

    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetUnstake(const Request &req, Response &res) 
{
    getUnStakeReq req_t;
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateUnstakingTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    
    std::string utxoHash = req_t.utxoHash;

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    std::pair<std::string,std::string> gastrade = req_t.gastrade ;
    gastrade.first = remove0xPrefix(gastrade.first);
    gastrade.second = remove0xPrefix(gastrade.second);
    bool isGasTrade = req_t.isGasTrade ; 
    

    ReplaceCreateUnstakeTransaction(fromAddr, utxoHash,gastrade,isGasTrade,isFindUtxoFlag,encodedInfo,&ack_t);

    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetDelegating(const Request &req, Response &res) {
    getDelegateReq req_t;
    txAck ack_t;

    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateDelegatingTransaction";
    ack_t.sleeptime = req_t.sleeptime;

       std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    std::string toAddr = remove0xPrefix(req_t.toAddr);
    std::string assetType = remove0xPrefix(req_t.assetType);
    if (fromAddr.substr(0, 2) == "0x") 
    {
        fromAddr = fromAddr.substr(2);
    }
    
    if (toAddr.substr(0, 2) == "0x") 
    {
        toAddr = toAddr.substr(2);
    }
    CHECK_VALUE(req_t.delegateAmount);
    long double value = std::stold(req_t.delegateAmount) * 10000;
    value = value * 10000;
    uint64_t delegatingAmout =(std::stod(req_t.delegateAmount) + global::ca::kFixDoubleMinPrecision) *global::ca::kDecimalNum;
    int32_t delegateType = std::stoll(req_t.delegateType);

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);

    std::pair<std::string,std::string> gastrade = req_t.gastrade ;
    gastrade.first = remove0xPrefix(gastrade.first);
    gastrade.second = remove0xPrefix(gastrade.second);
    bool isGasTrade = req_t.isGasTrade ; 
    ReplaceCreateDelegatingTransaction(
        fromAddr, assetType, toAddr, delegatingAmout, delegateType,gastrade,isGasTrade,isFindUtxoFlag,encodedInfo,&ack_t);
    
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetUndelegating(const Request &req, Response &res) 
{
    getUndelegatereq req_t;
    txAck ack_t;

    VALIDATE_JSON_REQUEST_PARSING    
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateUndelegatingTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    std::string assetType = remove0xPrefix(req_t.assetType);
    std::string toAddr = remove0xPrefix(req_t.toAddr);

    std::string utxoHash = req_t.utxoHash;
    if (utxoHash.substr(0, 2) == "0x") 
    {
        utxoHash = utxoHash.substr(2);
    }

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);

    std::pair<std::string,std::string> gastrade = req_t.gastrade ;
    gastrade.first = remove0xPrefix(gastrade.first);
    gastrade.second = remove0xPrefix(gastrade.second);
    bool isGasTrade = req_t.isGasTrade ; 

    ReplaceCreateUndelegatingTransaction(
        fromAddr, assetType, toAddr, utxoHash,gastrade,isGasTrade,isFindUtxoFlag,encodedInfo,&ack_t);

    res.set_content(ack_t._parseToString(), "application/json");
}

void _ApiGetYieldInfo(const Request &req, Response &res) 
{
    GetYieldInfoReq req_t;
    GetYieldInfoAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetYieldInfo";

    uint64_t curTime =
        MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();

    double annualizedRate = 0.0;

    ca_algorithm::GetAnnualizedRate(curTime, annualizedRate);
    ack_t.annualizedRate = std::to_string(annualizedRate);
    ack_t.code = 0;
    ack_t.message = "success";

    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetBonus(const Request &req, Response &res) 
{
    getBonusReq req_t;
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateBonusTransaction";
    ack_t.sleeptime = req_t.sleeptime;
    std::string addr = remove0xPrefix(req_t.addr);

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    req_t.gastrade.first = remove0xPrefix(req_t.gastrade.first);
    req_t.gastrade.second = remove0xPrefix(req_t.gastrade.second);
    processRewardTransaction(addr, req_t.assetType, req_t.gastrade, req_t.isGasTrade, isFindUtxoFlag, encodedInfo, &ack_t);
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetUndelegatingUtxo(const Request &req, Response &res) {
    get_UndelegateUtxo_ack ack_t;
    get_UndelegateUtxo_req req_t;

    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetUndelegatingUtxo";

    std::string toAddr = remove0xPrefix(req_t.toAddr);

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);

    DBReader dbReader;
    nlohmann::json resultJs;
    std::vector<std::string> utxoList;
    
    auto ret = dbReader.GetBonusAddrDelegatingAddrUtxoByBonusAddr(toAddr, fromAddr, remove0xPrefix(req_t.assetType), utxoList);
    if(ret!= DBStatus::DB_SUCCESS)
    {
        ack_t.code = -1;
        ack_t.message = "The address has no Delegating in anyone";
    }


    std::reverse(utxoList.begin(), utxoList.end());

    for(auto &utxo : utxoList)
    {
        resultJs["utxo"].push_back(utxo);
    }
    ack_t.code = 0;
    ack_t.message = "success";
    ack_t.utxos = resultJs;
    res.set_content(ack_t._parseToString(), "application/json");
    DEBUGLOG("http_api.cpp:GetUndelegatingUtxo ack_T.parseToString{}", ack_t._parseToString());
}


void _GetStakeUtxo(const Request &req, Response &res) {
    get_stakeutxo_ack ack_t;
    get_stakeutxo_req req_t;

    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetStakingUtxo";

    std::string strFromAddr =  remove0xPrefix(req_t.fromAddr);

    DBReader dbReader;
    std::vector<std::string> utxos;
    std::string assetType;
    int ret = ca_algorithm::GetCanBeRevokeAssetType(assetType);
    if(ret != 0){
        ack_t.code = -2;
        ack_t.message = "Get CanBeRevoke AssetType fail!";
    }

    ret = dbReader.FetchStakeUtxos(strFromAddr, assetType, utxos);
    if(ret != DBStatus::DB_SUCCESS)
    {
        ack_t.code = -1;
        ack_t.message = "fromaddr not stake!";
    }

    std::reverse(utxos.begin(), utxos.end());

    nlohmann::json outPut;
    for (auto &utxo : utxos) {
        std::string txRaw;
        dbReader.GetTransactionByHash(utxo, txRaw);
        CTransaction tx;
        tx.ParseFromString(txRaw);
        uint64_t value = 0;
        for(const auto & txUtxo : tx.utxos())
        {
            for (auto &vout : txUtxo.vout()) {
                if (vout.addr() == global::ca::kVirtualStakeAddr) {
                    value = vout.value();
                }
                outPut[utxo] = value;
            }
        }
    }

    ack_t.code = 0;
    ack_t.message = "success";
    ack_t.utxos = outPut;
    res.set_content(ack_t._parseToString(), "application/json");
    DEBUGLOG("http_api.cpp:GetStakingUtxo ack_T.parseToString{}",ack_t._parseToString());
}


void _GetTransaction(const Request &req, Response &res) 
{
    txAck ack_t;
    tx_req req_t;

    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    for (auto &t : req_t.txAsset)
    {
        t.assetType = remove0xPrefix(t.assetType);
        for(auto& fromAddr: t.fromAddr)
        {
            fromAddr = remove0xPrefix(fromAddr);
        }
        std::map<std::string, int64_t> addrToAmount;
        for(auto& toAddr: t.addrToAmount)
        {
            addrToAmount.insert(std::make_pair(remove0xPrefix(toAddr.first), toAddr.second));
        }
        t.addrToAmount = std::move(addrToAmount);
    } 

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    req_t.gastrade.first = remove0xPrefix(req_t.gastrade.first);
    req_t.gastrade.second = remove0xPrefix(req_t.gastrade.second);

    createTransaction(req_t.txAsset,req_t.gastrade,req_t.isGasTrade,isFindUtxoFlag,encodedInfo,&ack_t);
    
    res.set_content(ack_t._parseToString(), "application/json");
}



void _DeployContract(const Request &req, Response &res) {
    
    deploy_contract_req req_t;
    contractAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateDeployContractTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    ack_t.code = 0;
    ack_t.message = "success";

    std::string ret = RpcDeployContract((void *)&req_t, &ack_t);

    if (ack_t.code == -2300)
    {
        auto rpcError=GetRpcError();
        ack_t.code = std::atoi(rpcError.first.c_str());
        ack_t.message = rpcError.second;
    }
    
    
    res.set_content(ack_t._parseToString(), "application/json");
}



void _CallContract(const Request &req, Response &res) 
{
    RpcErrorClear();
    request req_t;
    contractAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING;

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateCallContractTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    ack_t.code = 0;
    ack_t.message = "success";

    std::string ret = RpcCallContract((void *)&req_t, &ack_t);

    if(ack_t.code == -2300)
    {
        auto rpcError=GetRpcError();
        ack_t.message = rpcError.second;
        ack_t.code = std::atoi(rpcError.first.c_str());
    }

    res.set_content(ack_t._parseToString(), "application/json");
}



void _ApiGetAllBonusInfo(const Request &req,Response &res)
{
    getAllbonusInfoReq req_t;
    getAllbonusInfoAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetBonusInfo";

    nlohmann::json addr_count_time;
    std::map<std::string, double> addr_percent;
    std::unordered_map<std::string, uint64_t> addrSignCnt;
    uint64_t curTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
    uint64_t morningTime = MagicSingleton<TimeUtil>::GetInstance()->GetMorningTime(curTime)*1000000;

    auto ret = ca_algorithm::abnormal_sign_addr_list(curTime, addr_percent, addrSignCnt);
    if(ret < 0) 
    {   
        ack_t.code = -1;
        ack_t.message = "DB get sign addr failed!";
        ERRORLOG("DB get sign addr failed!");
    }   

    addr_count_time["time"] = std::to_string(morningTime); 
    for(auto &it : addrSignCnt)
    {
        nlohmann::json addr_count;  
        addr_count["address"] = addHexPrefix(it.first);
        addr_count["count"] = it.second;
        addr_count_time["addr_count"].push_back(addr_count);
    }

    ack_t.code = 0;
    ack_t.message = "message";
    ack_t.info = addr_count_time;
    res.set_content(ack_t._parseToString(), "application/json");
}


void _GetAllStakeNodes(const Request & req,Response & res){
 
    get_all_stake_node_list_req req_t;
    nodeListConfirmation ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetAllStakeNodeList";

    std::shared_ptr<stake_node_list_request> p_req;
    GetAllStakeNodeListAck  p_ack;
    int ret = QueryStakeNodesImpl(p_req, p_ack);
    if(ret!=0){
        p_ack.set_code(ret);
    }

    std::string jsonstr;
    google::protobuf::util::Status status =
        google::protobuf::util::MessageToJsonString(p_ack, &jsonstr);
       if(!status.ok()){
            errorL("protobuff to json fail");
            jsonstr="protobuff to json fail";
       }
    ack_t.code = p_ack.code();
    ack_t.message = p_ack.message();
    ack_t.list = nlohmann::json::parse(jsonstr);
    res.set_content(ack_t._parseToString(),"application/json");
}


void _ConfirmTransaction(const Request &req, Response &res) 
{
    confirmReq req_t;
    confirm_transaction_ack ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "ConfirmTransaction";
    uint64_t height = std::stoll(req_t.height);
    ConfirmTransactionAck ack;
    std::shared_ptr<ConfirmTransactionReq> req_p = std::make_shared<ConfirmTransactionReq>();
    std::string txHash = req_t.txhash;
    if (txHash.substr(0, 2) == "0x") 
    {
        txHash = txHash.substr(2);
    }

    req_p->transactionHash(txHash);
    req_p->set_version(global::kVersion);
    req_p->set_height(height);
    auto currentTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
    req_p->set_time(currentTime);

    int ret = 0;
    ret = SendConfirmTransactionReq(req_p, ack);
    ack_t.code = ret;
    ack_t.message = "success";
    if(ret != 0)
    {
        ERRORLOG("sussize is empty{}",ret);
        ack_t.code = ret;
        ack_t.message = ack.message();
        res.set_content(ack_t._parseToString(),"application/json");
        return;
    }
    std::string debugValue;
    google::protobuf::util::Status status =
        google::protobuf::util::MessageToJsonString(ack, &debugValue);
     DEBUGLOG("http_api.cpp:ConfirmTransaction ack_t.parseToString {}",debugValue);

   
    auto sus = ack.percentage();
    auto susSize = sus.size();
    if(susSize == 0)
    {
        ERRORLOG("sussize is empty{}",susSize);
        ack_t.message = "susSize node list is empty";
        ack_t.code = -6;
        res.set_content(ack_t._parseToString(),"application/json");
        return;
    }
    std::string received_size = std::to_string(ack.received_size());
    int receivedSize = stoi(received_size);

    std::vector<Node> nodelist = MagicSingleton<PeerNode>::GetInstance()->GetNodelist();
    int sendsize = nodelist.size();
    if(receivedSize < sendsize * 0.5)
    {
      ack_t.code = -7;
      ack_t.message = "The amount received was too small to verify transaction on-chain";
      res.set_content(ack_t._parseToString(),"application/json");
      return;
    }


    auto rate = sus.at(0);
    ack_t.txhash = addHexPrefix(rate.hash());
    ack_t.percent = std::to_string(rate.rate());
    ack_t.receivedsize = std::to_string(ack.received_size());
    ack_t.sendsize = std::to_string(ack.send_size());

    CTransaction tx;
    if (!tx.ParseFromString(ack.tx())) {
        ack_t.code = -8;
        ack_t.message = "tx ParseFromString error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    ack_t.tx = nlohmann::json::parse(SerializeTransaction(tx));

    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetBlockHeight(const Request &req, Response &res){
    getblockheightrReq req_t;
    getblockheightrAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id=req_t.id;
    ack_t.method = "GetBlockHeight";
    ack_t.jsonrpc=req_t.jsonrpc;
    DBReader dbReader;
    uint64_t top = 0;

    if (DBStatus::DB_SUCCESS != dbReader.GetBlockTop(top)) {
        ack_t.code = -1;
        ack_t.message = "GetBlockTop error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    ack_t.height = std::to_string(top);
    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetVersion(const Request &req, Response &res) {
    getversionReq req_t;
    versionResponse ack_t;
    VALIDATE_JSON_REQUEST_PARSING
	ack_t.id=req_t.id;
    ack_t.method="GetVersion";
    ack_t.jsonrpc=req_t.jsonrpc;

    ack_t.clientVersion =global::kVersion;
    ack_t.netVersion =global::kNetVersion;
    ack_t.configVersion= MagicSingleton<Config>::GetInstance()->GetVersion();
    ack_t.dbVersion=global::kVersion;
    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetBalance(const Request &req, Response &res) {
    balanceReq req_t;
    balanceAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
	ack_t.id=req_t.id;
    ack_t.method="GetBalance";
    ack_t.jsonrpc=req_t.jsonrpc;
    std::string address = req_t.addr;
    std::string assetType = req_t.assetType;
    if (address.substr(0, 2) == "0x") 
    {
        address = address.substr(2);
    }
    assetType = remove0xPrefix(assetType);
    if (!isValidAddress(address))
    {
        ack_t.code = -1;
        ack_t.message = "address is invalid";
        ack_t.addr = addHexPrefix(address);
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    int64_t balance = 0;
    DBReader dbReader;
    auto ret = dbReader.GetBalanceByAddress(address, assetType ,balance); 
    if (ret != DBStatus::DB_SUCCESS && ret != DBStatus::DB_NOT_FOUND) 
    {
        ack_t.addr = addHexPrefix(address);
        ack_t.code = -2;
        ack_t.message = "search balance failed";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    ack_t.assetType = assetType;
    ack_t.addr = addHexPrefix(address);
    ack_t.balance=std::to_string(balance);
    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetBlockTransactionCountByHash(const Request &req, Response &res){
	getblocktransactioncountReq req_t;
	txCountAck ack_t;
	VALIDATE_JSON_REQUEST_PARSING
    std::string blockStr;
	DBReader dbReader;
	ack_t.id=req_t.id;
    ack_t.method="GetBlockTransactionCountByHash";
    ack_t.jsonrpc=req_t.jsonrpc;
	std::string blockHash = req_t.blockHash;
    if (blockHash.substr(0, 2) == "0x") 
    {
        blockHash = blockHash.substr(2);
    }
	if (DBStatus::DB_SUCCESS != dbReader.GetBlockByBlockHash(blockHash, blockStr)){
        ack_t.code = -1;
        ack_t.message = "GetBlockByBlockHash error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
	CBlock block;
    if (!block.ParseFromString(blockStr))
	{
        ack_t.code = -2;
        ack_t.message = "block parse string fail";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}
    uint64_t nums = 0;
    nums=block.txs().size();
    ack_t.txCount=std::to_string(nums);
	ack_t.code = 0;
    ack_t.message = "success";
	res.set_content(ack_t._parseToString(), "application/json");
}

void _GetAccounts(const Request &req, Response &res){
    getaccountsReq req_t;
    getaccountsAck ack_t;

    VALIDATE_JSON_REQUEST_PARSING
	ack_t.id=req_t.id;
    ack_t.method="GetAccounts";
    ack_t.jsonrpc=req_t.jsonrpc;
    DBReader dbReader;

    std::vector<std::string> list;
    std::vector<std::string> endlist;
    MagicSingleton<accountManager>::GetInstance()->GetAccountList(list);
    auto it = std::find(list.begin(), list.end(), MagicSingleton<accountManager>::GetInstance()->GetDefaultAddr());
    if (it != list.end()) {
        std::rotate(list.begin(), it, it + 1);
    }
      for (auto &i : list) {
        endlist.push_back("0x"+i); 
    }
    ack_t.acccountlist=endlist;
    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetChainId(const Request &req, Response &res){
    chainIdRequest req_t;
    chainIdResponse ack_t;

    VALIDATE_JSON_REQUEST_PARSING
	ack_t.id=req_t.id;
    ack_t.method="GetChainId";
    ack_t.jsonrpc=req_t.jsonrpc;

    std::string blockHash;
    DBReader dbReader;
    if(DBStatus::DB_SUCCESS != dbReader.getBlockHashByHeight(0, blockHash))
    {
        ack_t.message = "Get block hash error";
        ack_t.code = -1;
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    
    blockHash = blockHash.substr(0,8);
    ack_t.chainId= addHexPrefix(blockHash);
    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}

std::vector<std::string> splitString(const std::string& str) {
    std::vector<std::string> result;
    std::regex rgx(R"(ip\((\d+\.\d+\.\d+\.\d+)\)\s+port\((\d+)\)\s+ip_l\((\d+\.\d+\.\d+\.\d+)\)\s+port_l\((\d+)\)\s+kind\((\d+)\)\s+fd\((\d+)\)\s+addr\(0x([a-fA-F0-9]+)\)\s+pulse\((\d+)\)\s+height\(\s*(\d+)\s*\)\s+name\(([^)]*)\)\s+version\((\d+_\d+\.\d+\.\d+_[ptd])\)\s+logo\(([^)]*)\))");
    std::sregex_iterator iter(str.begin(), str.end(), rgx);
    std::sregex_iterator end;

    while (iter != end) {
        result.push_back(iter->str());
        ++iter; 
    }

    return result;
}

nlohmann::json parseEntry(const std::string& entry) {
    std::regex rgx(R"(ip\((\d+\.\d+\.\d+\.\d+)\)\s+port\((\d+)\)\s+ip_l\((\d+\.\d+\.\d+\.\d+)\)\s+port_l\((\d+)\)\s+kind\((\d+)\)\s+fd\((\d+)\)\s+addr\(0x([a-fA-F0-9]+)\)\s+pulse\((\d+)\)\s+height\(\s*(\d+)\s*\)\s+name\(([^)]*)\)\s+version\((\d+_\d+\.\d+\.\d+_[ptd])\)\s+logo\(([^)]*)\))");
    std::smatch match;
    nlohmann::json j;

    if (std::regex_search(entry, match, rgx)) {
        j["ip"] = match[1].str();
        j["port"] = match[2].str();
        j["ip_l"] = match[3].str();
        j["port_l"] = match[4].str();
        j["kind"] = match[5].str();
        j["fd"] = match[6].str();
        j["addr"] = "0x"+match[7].str();
        j["pulse"] = match[8].str();
        j["height"] = match[9].str();
        j["name"] =  match[10].str(); 
        j["version"] = match[11].str();
        j["logo"] = Base64Encode(match[12].str()); 
    }

    return j;
}


void _GetPeerList(const Request &req, Response &res) 
{
    getpeerlistReq req_t;
    getpeerlistAck ack_t;

    nlohmann::json infoList;
    std::ostringstream oss;
    VALIDATE_JSON_REQUEST_PARSING
	ack_t.id=req_t.id;
    ack_t.method="GetNodeList";
    ack_t.jsonrpc=req_t.jsonrpc;


    std::vector<std::string> baseList;
    std::vector<Node> nodeList =MagicSingleton<PeerNode>::GetInstance()->GetNodelist();
    std::string strlist=MagicSingleton<PeerNode>::GetInstance()->NodelistInfo(nodeList);

    std::vector<std::string> result = splitString(strlist);
    nlohmann::json j_array =  nlohmann::json::array();
    for (const auto& entry : result) {
        j_array.push_back(parseEntry(entry));
    }
    ack_t.nodeList=j_array;
    ack_t.size=nodeList.size();
    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}


void getTransactionInfo(const Request &req,Response &res)
{
    getTransactionInfoReq req_t;
    getTransactionInfoAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetTransactionByHash";

    DBReader dbReader;
	std::string strTx;
	if (DBStatus::DB_SUCCESS != dbReader.GetTransactionByHash(remove0xPrefix(req_t.txHash), strTx))
	{
        ack_t.code = -1;
        ack_t.message = "Tx hash error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}

	CTransaction tx;
	if (!tx.ParseFromString(strTx))
	{
        ack_t.code = -2;
        ack_t.message = "Failed to parse transaction body";
        res.set_content(ack_t._parseToString(), "application/json");
		return;
	}

    ack_t.code = 0;
    ack_t.message = "success";
    ack_t.tx = nlohmann::json::parse(SerializeTransaction(tx));
    
    res.set_content(ack_t._parseToString(), "application/json");
}


void RetrieveBlockByTxHash(const Request & req, Response & res)
{
    txHashRequest req_t;
    getBlockInfoByTxHashAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetBlockByTransactionHash";

    DBReader dbReader;
    std::string blockHash;
    if (DBStatus::DB_SUCCESS != dbReader.blockHashByTxHash(remove0xPrefix(req_t.txHash), blockHash))
	{
        ack_t.code = -1;
        ack_t.message = "Tx hash error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}

	std::string strBlock;
	if (DBStatus::DB_SUCCESS != dbReader.GetBlockByBlockHash(blockHash, strBlock))
	{
        ack_t.code = -2;
        ack_t.message = "Block hash error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}

    nlohmann::json block;
    BlockInvert(strBlock, block);
    if(block.empty())
    {
        ack_t.code = -3;
        ack_t.message = "Block invert error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    ack_t.code = 0;
    ack_t.message = "success";
    ack_t.blockInfo = nlohmann::json::parse(block.dump());
    res.set_content(ack_t._parseToString(), "application/json");
}



void _ApiGetBlockByHash(const Request &req,Response &res)
{
    getBlockInfoByHashReq req_t;
    ack ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetBlockByHash";

    DBReader dbReader;
	std::string strBlock;
	if (DBStatus::DB_SUCCESS != dbReader.GetBlockByBlockHash(remove0xPrefix(req_t.blockHash), strBlock))
	{
        ack_t.code = -1;
        ack_t.message = "Block hash error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}

    nlohmann::json block;
    BlockInvert(strBlock, block);

    ack_t.code = 0;
    ack_t.message = "success";
    ack_t.blockInfo = nlohmann::json::parse(block.dump());
    res.set_content(ack_t._parseToString(), "application/json");
}


void _ApiGetBlockByHeight(const Request &req,Response &res)
{
    heightRangeRequest req_t;
    getBlockInfoByHeightAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetBlockByHeight";

    DBReader dbReader;
    uint64_t blockHeight;
    if (DBStatus::DB_SUCCESS != dbReader.GetBlockTop(blockHeight))
    {
        ack_t.code = -5;
        ack_t.message = "Database abnormal, Get block top error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    uint64_t beginHeight = std::stoull(req_t.beginHeight);
    uint64_t endHeight = std::stoull(req_t.endHeight);
    if(endHeight > blockHeight)
    {
        endHeight = blockHeight;
    }
    if(beginHeight > blockHeight)
    {
        beginHeight = blockHeight;
    }

    if(beginHeight > endHeight)
    {
        ack_t.code = -1;
        ack_t.message = "Block height error, beginHeight < endHeight";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    if(endHeight - beginHeight > 100)
    {
        ack_t.code = -2;
        ack_t.message = "The height of the request does not exceed 100";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    std::vector<std::string> blockHashes;
	if (DBStatus::DB_SUCCESS != dbReader.FetchBlockHashesInRange(beginHeight, endHeight, blockHashes))
	{
        ack_t.code = -3;
        ack_t.message = "Database abnormal, Get block hashes by block height error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}

    std::string strBlock;
    for(const auto& t : blockHashes)
    {
        if (DBStatus::DB_SUCCESS != dbReader.GetBlockByBlockHash(t, strBlock))
        {
            ack_t.code = -4;
            ack_t.message = "Database abnormal, Get block by block hash error, block hash: " + t;
            res.set_content(ack_t._parseToString(), "application/json");
            ack_t.blocks.clear();
            return;
        }
        
        nlohmann::json block;
        BlockInvert(strBlock, block);
        ack_t.blocks.emplace_back(std::move(nlohmann::json::parse(block.dump())));
    }

    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
}

void _ApiSendMessage(const Request &req, Response &res) 
{
    rpcAck ack_t;
    txAck req_t;
    VALIDATE_JSON_REQUEST_PARSING;

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "SendMessage";

    CTransaction tx;
    Vrf info;
    int height;
    TxHelper::VrfAgentCategory type;
    google::protobuf::util::Status status =
    google::protobuf::util::JsonStringToMessage(req_t.txJson, &tx);
    status = google::protobuf::util::JsonStringToMessage(req_t.vrfData, &info);

    height = std::stoi(req_t.height);
    type = (TxHelper::VrfAgentCategory)std::stoi(req_t.txType);
    std::string txHash = Getsha256hash(tx.SerializeAsString());
    ack_t.txHash = addHexPrefix(txHash);
    int ret = SendMessage(tx, height, info, type);
    DEBUGLOG("*** rpc send tx hash: {}", txHash);


    if(0 < std::stoi(req_t.sleeptime) && std::stoi(req_t.sleeptime) <= 10){
        std::this_thread::sleep_for(std::chrono::seconds(std::stoi(req_t.sleeptime)));
        ConfirmTransactionAck ack;
        std::shared_ptr<ConfirmTransactionReq> req_p = std::make_shared<ConfirmTransactionReq>();
        req_p->transactionHash(txHash);
        req_p->set_version(global::kVersion);
        req_p->set_height(height);
        auto currentTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
        req_p->set_time(currentTime);
        ret = SendConfirmTransactionReq(req_p, ack);
        if(ret != 0)
        {
            ERRORLOG("sussize is empty{}",ret);
            ack_t.code = ret;
            ack_t.message = ack.message();
            res.set_content(ack_t._parseToString(),"application/json");
            return;
        }

        std::string debugValue;
        google::protobuf::util::Status status =
            google::protobuf::util::MessageToJsonString(ack, &debugValue);
        DEBUGLOG("http_api.cpp:ConfirmTransaction ack_t.parseToString {}",debugValue);

        auto sus = ack.percentage();
        auto susSize = sus.size();
        if(susSize == 0)
        {
            ERRORLOG("sussize is empty{}",susSize);
            ack_t.message = "susSize node list is empty";
            ack_t.code = -6;
            res.set_content(ack_t._parseToString(),"application/json");
            return;
        }
        std::string received_size = std::to_string(ack.received_size());
        int receivedSize = stoi(received_size);

        std::vector<Node> nodelist = MagicSingleton<PeerNode>::GetInstance()->GetNodelist();
        int sendsize = nodelist.size();
        if(receivedSize < sendsize * 0.5)
        {
            ack_t.code = -7;
            ack_t.message = "The amount received was too small to verify transaction on-chain";
            res.set_content(ack_t._parseToString(),"application/json");
            return;
        }

        auto rate = sus.at(0);
        ack_t.percent = std::to_string(rate.rate());
        ack_t.receivedsize = std::to_string(ack.received_size());
        ack_t.sendsize = std::to_string(ack.send_size());

        CTransaction tx;
        if (!tx.ParseFromString(ack.tx())) {
            ack_t.code = -8;
            ack_t.message = "tx ParseFromString error";
            res.set_content(ack_t._parseToString(), "application/json");
            return;
        }
        ack_t.tx = SerializeTransaction(tx);
    }

    ack_t.code = ret;
    ret == 0 ? ack_t.message = "success" : ack_t.message = "TxHelper::SendMessage error";

    std::string back = ack_t._parseToString();
    res.set_content(back, "application/json");
}

void handleSendContractMessage(const Request & req,Response & res){
    contractAck ack_p;
    rpcAck ack_t;
    if(ack_p._parseFromJson(req.body)!="OK"){
        errorL("parse fail");
        return;
    }

    ack_t.id = ack_p.id;
    ack_t.jsonrpc = ack_p.jsonrpc;
    ack_t.method = "SendContractMessage"; 

    contractTxMessage ContractMsg;
    CTransaction tx;
    google::protobuf::util::JsonStringToMessage(ack_p.contractJs, &ContractMsg);
    google::protobuf::util::JsonStringToMessage(ack_p.txJson, &tx);


    std::string txHash = Getsha256hash(tx.SerializeAsString());
    tx.set_hash(txHash);
    DEBUGLOG("*** rpc send contract tx hash: {}", txHash);
    
    ack_t.txHash = addHexPrefix(txHash);
    ack_t.code = 0;
    ack_t.message = "success";

    TxMsgReq txReq= ContractMsg.txmsgreq();
    TxMsgInfo info=txReq.txmsginfo();
    info.set_tx(tx.SerializeAsString());
    txReq.clear_txmsginfo();
    TxMsgInfo *info_p=txReq.mutable_txmsginfo();
    info_p->CopyFrom(info);
    ContractMsg.clearTxMsgReq();
    TxMsgReq * txReq_p=ContractMsg.mutable_txmsgreq();
    txReq_p->CopyFrom(txReq);
    auto msg = std::make_shared<contractTxMessage>(ContractMsg);
    ProcessAndShipTransaction(msg,tx);

    if(0 < std::stoi(ack_p.sleeptime) && std::stoi(ack_p.sleeptime) <= 10){
        std::this_thread::sleep_for(std::chrono::seconds(std::stoi(ack_p.sleeptime)));
        ConfirmTransactionAck ack;
        std::shared_ptr<ConfirmTransactionReq> req_p = std::make_shared<ConfirmTransactionReq>();
        req_p->transactionHash(txHash);
        req_p->set_version(global::kVersion);
        req_p->set_height(std::stoi(ack_p.height));
        auto currentTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
        req_p->set_time(currentTime);
        int ret = SendConfirmTransactionReq(req_p, ack);
        if(ret != 0)
        {
            ERRORLOG("sussize is empty{}",ret);
            ack_t.code = ret;
            ack_t.message = ack.message();
            res.set_content(ack_t._parseToString(),"application/json");
            return;
        }

        std::string debugValue;
        google::protobuf::util::Status status =
            google::protobuf::util::MessageToJsonString(ack, &debugValue);
        DEBUGLOG("http_api.cpp:ConfirmTransaction ack_t.parseToString {}",debugValue);

        auto sus = ack.percentage();
        auto susSize = sus.size();
        if(susSize == 0)
        {
            ERRORLOG("sussize is empty{}",susSize);
            ack_t.message = "susSize node list is empty";
            ack_t.code = -6;
            res.set_content(ack_t._parseToString(),"application/json");
            return;
        }
        std::string received_size = std::to_string(ack.received_size());
        int receivedSize = stoi(received_size);

        std::vector<Node> nodelist = MagicSingleton<PeerNode>::GetInstance()->GetNodelist();
        int sendsize = nodelist.size();
        if(receivedSize < sendsize * 0.5)
        {
            ack_t.code = -7;
            ack_t.message = "The amount received was too small to verify transaction on-chain";
            res.set_content(ack_t._parseToString(),"application/json");
            return;
        }

        auto rate = sus.at(0);
        ack_t.percent = std::to_string(rate.rate());
        ack_t.receivedsize = std::to_string(ack.received_size());
        ack_t.sendsize = std::to_string(ack.send_size());

        CTransaction tx;
        if (!tx.ParseFromString(ack.tx())) {
            ack_t.code = -8;
            ack_t.message = "tx ParseFromString error";
            res.set_content(ack_t._parseToString(), "application/json");
            return;
        }
        ack_t.tx = nlohmann::json::parse(SerializeTransaction(tx));
    }

    res.set_content(ack_t._parseToString(), "application/json");
}

void fetch_delegate_info_request(const Request &req, Response &res)
{
    GetDelegateReq req_t;
    GetDelegateAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING;

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetDelegatingAddrsByBonusAddr";

    std::string addr = req_t.addr;
    if (addr.substr(0, 2) == "0x") 
    {
        addr = addr.substr(2);
    }

    int ret = 0;
    std::string errMessage = "success";
    do
    {
        DBReader dbReader;
        std::multimap<std::string, std::string> addresses_assetType;
        auto status = dbReader.GetDelegatingAddrByBonusAddr(addr, addresses_assetType);
        if (status != DBStatus::DB_SUCCESS && status != DBStatus::DB_NOT_FOUND)
        {
            errMessage = "Database abnormal, Get delegating addrs by node failed!";
            ret = -1;
            break;
        }
        if (addresses_assetType.size() + 1 > 999)
        {
            errMessage = "The account number to be delegatinged have been delegatinged by 999 people!";
            ret = -2;
            break;
        }

        for (auto &[delegatingAddr, assetType] : addresses_assetType)
        {
            std::vector<std::string> utxos;
            if (dbReader.GetBonusAddrDelegatingAddrUtxoByBonusAddr(addr, delegatingAddr, assetType, utxos) != DBStatus::DB_SUCCESS)
            {
                ERRORLOG("GetBonusAddrDelegatingAddrUtxoByBonusAddr failed!");
                errMessage = "Get bonus addr delegating addr utxo failed!";
                ret = -3;
                break;
            }

            for (const auto &utxo : utxos)
            {
                std::string strTx;
                if (dbReader.GetTransactionByHash(utxo, strTx) != DBStatus::DB_SUCCESS)
                {
                    ERRORLOG("GetTransactionByHash failed!");
                    errMessage = "Get transaction failed!";
                    ret = -4;
                    break;
                }

                CTransaction tx;
                if (!tx.ParseFromString(strTx))
                {
                    ERRORLOG("Failed to parse transaction body!");
                    errMessage = "Failed to parse transaction body!";
                    ret = -5;
                    break;
                }
                for(auto &txUtxo : tx.utxos())
                {
                    for(auto &vout: txUtxo.vout()){
                        if (vout.addr() == global::ca::kVirtualDelegatingAddr)
                        {
                            ack_t.info[delegatingAddr].emplace_back(std::make_pair(assetType, std::to_string(vout.value())));
                            break;
                        }
                    }
                }
            }
        }
    } while(0);
    
    ack_t.code = ret;
    ack_t.message = errMessage;
    if(ret != 0)
    {
        ack_t.info.clear();
    }
    res.set_content(ack_t._parseToString(), "application/json");
}

void print_block_info(const Request &req, Response &res) 
{
    int num = 100;
    if (req.has_param("num")) {
        num = atol(req.get_param_value("num").c_str());
    }
    int startNum = 0;
    if (req.has_param("height")) {
        startNum = atol(req.get_param_value("height").c_str());
    }
    int hash = 0;
    if (req.has_param("hash")) {
        hash = atol(req.get_param_value("hash").c_str());
    }

    std::string str;
    bool html_format = req.has_param("html") && req.get_param_value("html") == "true";

    if (html_format) {
        str = "<!DOCTYPE html>\n<html>\n<head>\n";
        str += "<meta charset='UTF-8'>\n";
        str += "<title>MeMeChain Block List</title>\n";
        str += "<style>\n";
        str += "body { background: #000; color: #fff; font-family: Arial, sans-serif; margin: 0; padding: 0; }\n";
        str += ".header { display: flex; align-items: center; padding: 30px 0 0 60px; }\n";
        str += ".logo-img { height: 48px; }\n";
        str += ".footer { position: fixed; left: 0; bottom: 0; width: 100%; height: 80px; background: #111; border-top: 2px solid #222; display: flex; align-items: center; z-index: 10; }\n";
        str += ".footer-logo-img { height: 48px; margin-left: auto; margin-right: 20%; }\n";
        str += ".main-title { margin-left: 60px; margin-top: 20px; font-size: 22px; color: #fff; font-weight: 500; text-align: left; font-style: italic; }\n";
        str += ".divider { width: 60%; min-width: 400px; margin: 18px 0 0 60px; border-bottom: 2px solid #222; text-align: left; }\n";
        str += ".block-table { width: 60%; min-width: 400px; margin: 20px 0 80px 60px; border-collapse: separate; border-spacing: 0 10px; text-align: left; }\n";
        str += ".block-table th { font-size: 20px; color: #fff; background: none; border: none; text-align: left; padding-bottom: 10px; font-style: italic; }\n";
        str += ".block-table td { font-size: 22px; color: #fff; background: none; border: none; padding: 6px 0; vertical-align: middle; text-align: left; font-style: normal; }\n";
        str += ".block-table .height { font-weight: bold; color: #bdbdbd; width: 80px; }\n";
        str += ".block-table .blockhash {margin-right: 18px; font-style: normal; }\n";
        str += ".block-table .green { color: #4efcbf; }\n";
        str += ".block-table .blue { color: #4ecbfc; }\n";
        str += ".block-table .vline { display: inline-block; width: 2px; height: 28px; background: #444; margin: 0 8px; vertical-align: middle; border-radius: 2px; }\n";
        str += "</style>\n</head>\n<body>\n";
        // str += "<div class='header'><img class='logo-img' src='/memechain_logo.png' alt='MeMeChain Logo'></div>\n";
        str += "<div class='header'><img class='logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
        str += "<div class='main-title'>Block List</div>\n";
        str += "<div class='divider'></div>\n";
        str += "<table class='block-table'>\n<thead><tr><th style='width:120px;'>Height</th><th></th><th>Blockhash</th></tr></thead>\n<tbody>\n";

        DBReader dbReader;
        uint64_t top = 0;
        if (DBStatus::DB_SUCCESS != dbReader.GetBlockTop(top)) {
            str += "<tr><td colspan='3'>Get block height failed</td></tr>\n";
        } else {
            int count = 0;
            for (uint64_t i = top; i > 0 && count < num; i--) {
                std::vector<std::string> blockHashs;
                if (dbReader.FetchHashesForHeight(i, blockHashs) != DBStatus::DB_SUCCESS) {
                    continue;
                }
                if (blockHashs.empty()) {
                    continue;
                }
                str += "<tr>";
                str += "<td class='height'>" + std::to_string(i) + "</td>";
                str += "<td><span class='vline'></span></td>";
                str += "<td>";
                for (size_t j = 0; j < blockHashs.size(); ++j) {
                    std::string strHeader;
                    if (dbReader.GetBlockByBlockHash(blockHashs[j], strHeader) != DBStatus::DB_SUCCESS) {
                        continue;
                    }
                    CBlock block;
                    if (!block.ParseFromString(strHeader)) {
                        continue;
                    }
                    // Determine if contract block
                    bool isContractBlock = false;
                    for (const auto &tx : block.txs()) {
                        if ((global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeDeployContract || 
                            (global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeCallContract) {
                            isContractBlock = true;
                            break;
                        }
                    }
                    std::string colorClass = isContractBlock ? "blue" : "green";
                    str += "<span class='blockhash " + colorClass + "'>" + blockHashs[j].substr(0, 8) + "</span> ";
                }
                str += "</td></tr>\n";
                count++;
                if (count >= num) {
                    break;
                }
            }
        }
        str += "</tbody></table>\n";
        // str += "<div class='footer'><img class='footer-logo-img' src='/memechain_logo.png' alt='MeMeChain Logo'></div>\n";
        str += "<div class='footer'><img class='footer-logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
        str += "</body>\n</html>";
        res.set_content(str, "text/html");
        return;
    }

    DBReader dbReader;
    
    if (hash) {
        if (html_format) {
            // PrintBlocksHash's HTML version
            uint64_t top = 0;
            if (DBStatus::DB_SUCCESS != dbReader.GetBlockTop(top)) {
                str += "<tr><td colspan='2' class='error'>Get block height failed</td></tr>\n";
            } else {
                int count = 0;
                for (uint64_t i = top; i > 0 && count < num; i--) {
                    std::vector<std::string> blockHashs;
                    if (dbReader.FetchHashesForHeight(i, blockHashs) != DBStatus::DB_SUCCESS) {
                        continue;
                    }

                    if (blockHashs.empty()) {
                        continue;
                    }

                    // Add height cell when displaying the first block hash of each height
                    str += "<tr>\n";
                    str += "<td class='height-cell'>" + std::to_string(i) + "</td>\n";
                    str += "<td><div class='hash-container'>";
                    
                    for (const auto &blockHash : blockHashs) {
                        std::string strHeader;
                        bool isContractBlock = false;
                        
                        if (dbReader.GetBlockByBlockHash(blockHash, strHeader) == DBStatus::DB_SUCCESS) {
                            CBlock block;
                            if (block.ParseFromString(strHeader)) {
                                for (const auto &tx : block.txs()) {
                                    if ((global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeDeployContract || 
                                        (global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeCallContract) {
                                        isContractBlock = true;
                                        break;
                                    }
                                }
                                
                                str += "<span class='hash-cell ";
                                str += (isContractBlock ? "contract-block" : "normal-block");
                                str += "'>" + blockHash.substr(0, 8) + "</span>";
                                
                                if (req.has_param("pre_hash_flag")) {
                                    str += "<span class='hash-cell'>(" + block.prevhash().substr(0, 8) + ")</span>";
                                }
                            }
                        }
                    }
                    
                    str += "</div></td>\n";
                    str += "</tr>\n";
                    
                    count++;
                    if (count >= num) {
                        break;
                    }
                }
            }
            
            str += "</tbody>\n</table>\n</div>\n</body>\n</html>";
            res.set_content(str, "text/html");
        } else {
            str = PrintBlocksHash(num, req.has_param("pre_hash_flag"));
            res.set_content(str, "text/plain");
        }
        return;
    }

    if (startNum == 0) {
        if (html_format) {
            // DisplayContracts's HTML version
            uint64_t top = 0;
            if (DBStatus::DB_SUCCESS != dbReader.GetBlockTop(top)) {
                str += "<tr><td colspan='2' class='error'>Get block height failed</td></tr>\n";
            } else {
                int count = 0;
                for (uint64_t i = top; i > 0 && count < num; i--) {
                    std::vector<std::string> blockHashs;
                    if (dbReader.FetchHashesForHeight(i, blockHashs) != DBStatus::DB_SUCCESS) {
                        continue;
                    }

                    if (blockHashs.empty()) {
                        continue;
                    }

                    // Add height cell when displaying the first block hash of each height
                    str += "<tr>\n";
                    str += "<td class='height-cell'>" + std::to_string(i) + "</td>\n";
                    str += "<td><div class='hash-container'>";
                    
                    for (const auto &blockHash : blockHashs) {
                        std::string strHeader;
                        if (dbReader.GetBlockByBlockHash(blockHash, strHeader) != DBStatus::DB_SUCCESS) {
                            continue;
                        }

                        CBlock block;
                        if (!block.ParseFromString(strHeader)) {
                            continue;
                        }

                        bool isContractBlock = false;
                        for (const auto &tx : block.txs()) {
                            if ((global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeDeployContract || 
                                (global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeCallContract) {
                                isContractBlock = true;
                                break;
                            }
                        }

                        str += "<span class='hash-cell ";
                        str += (isContractBlock ? "contract-block" : "normal-block");
                        str += "'>" + blockHash.substr(0, 8) + "</span>";
                        
                        if (req.has_param("pre_hash_flag")) {
                            str += "<span class='hash-cell'>(" + block.prevhash().substr(0, 8) + ")</span>";
                        }
                    }
                    
                    str += "</div></td>\n";
                    str += "</tr>\n";
                    
                    count++;
                    if (count >= num) {
                        break;
                    }
                }
            }
            
            str += "</tbody>\n</table>\n</div>\n</body>\n</html>";
            res.set_content(str, "text/html");
        } else {
            str = DisplayContracts(num, req.has_param("pre_hash_flag"));
            res.set_content(str, "text/plain");
        }
    } else {
        if (html_format) {
            // PrintRangeContractBlocks's HTML version
            uint64_t top = 0;
            if (startNum <= 0) {
                str += "<tr><td colspan='2' class='error'>The starting block height must be greater than 0</td></tr>\n";
            } else if (DBStatus::DB_SUCCESS != dbReader.GetBlockTop(top)) {
                str += "<tr><td colspan='2' class='error'>Get block height failed</td></tr>\n";
            } else if (startNum > top) {
                str += "<tr><td colspan='2' class='error'>The starting block height exceeds the current highest block</td></tr>\n";
            } else {
                int count = 0;
                for (uint64_t i = startNum; i <= top && count < num; i++) {
                    std::vector<std::string> blockHashs;
                    if (dbReader.FetchHashesForHeight(i, blockHashs) != DBStatus::DB_SUCCESS) {
                        continue;
                    }

                    if (blockHashs.empty()) {
                        continue;
                    }

                    // Add height cell when displaying the first block hash of each height
                    str += "<tr>\n";
                    str += "<td class='height-cell'>" + std::to_string(i) + "</td>\n";
                    str += "<td><div class='hash-container'>";
                    
                    for (const auto &blockHash : blockHashs) {
                        std::string strHeader;
                        if (dbReader.GetBlockByBlockHash(blockHash, strHeader) != DBStatus::DB_SUCCESS) {
                            continue;
                        }

                        CBlock block;
                        if (!block.ParseFromString(strHeader)) {
                            continue;
                        }

                        bool isContractBlock = false;
                        for (const auto &tx : block.txs()) {
                            if ((global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeDeployContract || 
                                (global::ca::TxType)tx.txtype() == global::ca::TxType::kTxTypeCallContract) {
                                isContractBlock = true;
                                break;
                            }
                        }

                        str += "<span class='hash-cell ";
                        str += (isContractBlock ? "contract-block" : "normal-block");
                        str += "'>" + blockHash.substr(0, 8) + "</span>";
                        
                        if (req.has_param("pre_hash_flag")) {
                            str += "<span class='hash-cell'>(" + block.prevhash().substr(0, 8) + ")</span>";
                        }
                    }
                    
                    str += "</div></td>\n";
                    str += "</tr>\n";
                    
                    count++;
                    if (count >= num) {
                        break;
                    }
                }
            }
            
            str += "</tbody>\n</table>\n</div>\n</body>\n</html>";
            res.set_content(str, "text/html");
        } else {
            str = PrintRangeContractBlocks(startNum, num, req.has_param("pre_hash_flag"));
            res.set_content(str, "text/plain");
        }
    }
}

void ApiInfo(const Request &req, Response &res) 
{
    std::ostringstream oss;

    oss << "queue:" << std::endl;
    oss << "g_queueRead:" << global::g_queueRead.msgQueue.size() << std::endl;
    oss << "g_queueWork:" << global::g_queueWork.msgQueue.size() << std::endl;
    oss << "g_queueWrite:" << global::g_queueWrite.msgQueue.size() << std::endl;
    oss << "\n" << std::endl;

    oss << "amount:" << std::endl;
    std::vector<std::string> baseList;

    MagicSingleton<accountManager>::GetInstance()->GetAccountList(baseList);
    for (auto &i : baseList) {
        uint64_t amount = 0;
        GetBalanceByUtxo(i, global::ca::ballotAssetType, amount);
        oss << "0x"+i + ":" + std::to_string(amount) << std::endl;
    }
    oss << "\n" << std::endl;

    std::vector<Node> nodeList =
        MagicSingleton<PeerNode>::GetInstance()->GetNodelist();
    oss << "Public PeerNode size is: " << nodeList.size() << std::endl;
    oss << MagicSingleton<PeerNode>::GetInstance()->NodelistInfo(nodeList);

    oss << std::endl << std::endl;

    res.set_content(oss.str(), "text/plain");
}

void _ApiGetBlock(const Request &req, Response &res) {
    nlohmann::json block;
    nlohmann::json blocks;

    int top = 0;
    if (req.has_param("top")) {
        top = atol(req.get_param_value("top").c_str());
    }
    int num = 0;
    if (req.has_param("num")) {
        num = atol(req.get_param_value("num").c_str());
    }

    num = num > 500 ? 500 : num;

    if (top < 0 || num < 0) {
        ERRORLOG("_ApiGetBlock top < 0||num < 0");
        return;
    }

    DBReader dbReader;
    uint64_t myTop = 0;
    dbReader.GetBlockTop(myTop);
    if (top > (int)myTop) {
        ERRORLOG("_ApiGetBlock begin > myTop");
        return;
    }
    int k = 0;
    uint64_t countNum = top + num;
    if (countNum > myTop) {
        countNum = myTop;
    }
    for (auto i = top; i <= countNum; i++) {
        std::vector<std::string> blockHashs;

        if (dbReader.FetchHashesForHeight(i, blockHashs) !=
            DBStatus::DB_SUCCESS) 
        {
            return;
        }

        for (auto hash : blockHashs) 
        {
            std::string strHeader;
            if (dbReader.GetBlockByBlockHash(hash, strHeader) !=
                DBStatus::DB_SUCCESS) 
            {
                return;
            }
            BlockInvert(strHeader, block);
            blocks[k++] = block;
        }
    }
    std::string str = blocks.dump();
    res.set_content(str, "application/json");
}

void _ShowValidatedVRFs(const Request &req, Response &res) 
{
    std::string content = MagicSingleton<VRFConsensusNode>::GetInstance()->printfValidatedVRfs();

    res.set_content(content, "text/plain");
}

void _ShowNewValidatedVRFs(const Request &req, Response &res) 
{
    std::string content = MagicSingleton<VRFConsensusNode>::GetInstance()->printfNewValidatedVRfs();

    res.set_content(content, "text/plain");
}

void _ApiPub(const Request &req, Response &res) 
{
    std::string str;
    str = "<!DOCTYPE html>\n<html>\n<head>\n";
    str += "<meta charset='UTF-8'>\n";
    str += "<title>MeMeChain Thread Info</title>\n";
    str += "<style>\n";
    str += "body { background: #000; color: #fff; font-family: 'Arial', sans-serif; margin: 0; padding: 0; }\n";
    str += ".header { display: flex; align-items: center; padding: 30px 0 0 60px; }\n";
    str += ".logo-img { height: 48px; }\n";
    str += ".footer { position: fixed; left: 0; bottom: 0; width: 100%; height: 80px; background: #111; border-top: 2px solid #222; display: flex; align-items: center; z-index: 10; }\n";
    str += ".footer-logo-img { height: 48px; margin-left: auto; margin-right: 20%; }\n";
    str += ".main-title { margin-left: 60px; margin-top: 20px; font-size: 22px; color: #fff; font-weight: 500; text-align: left; font-style: italic; }\n";
    str += ".divider { width: 90%; min-width: 400px; margin: 18px 0 0 60px; border-bottom: 2px solid #222; text-align: left; }\n";

    str += ".task-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; width: 90%; margin: 20px 0 30px 60px; }\n";
    str += ".task-card { background: #111; border-radius: 6px; padding: 15px; border-left: 3px solid #444; transition: all 0.3s ease; }\n";
    str += ".task-card:hover { border-left-color: #00A046; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); }\n";
    str += ".task-title { color: #00C853; font-weight: bold; margin-bottom: 8px; font-size: 14px; }\n";
    str += ".task-value { color: #bdbdbd; font-family: monospace; font-size: 13px; }\n";
    str += ".task-zero { color: #555; }\n";
    str += ".task-grid-title { color: #888; margin: 5px 0 15px 60px; font-size: 16px; font-style: italic; }\n";
    str += ".system-info { background: #111; border-radius: 6px; padding: 15px; margin: 0 0 20px 60px; width: 90%; max-width: 1200px; }\n";
    str += ".info-row { display: flex; margin-bottom: 10px; }\n";
    str += ".info-label { color: #00C853; width: 130px; font-weight: bold; }\n";
    str += ".info-value { color: #bdbdbd; font-family: monospace; flex-grow: 1; }\n";
    str += ".section-gap { margin-top: 30px; }\n";

    str += ".data-table { width: 90%; min-width: 400px; margin: 20px 0 80px 60px; border-collapse: separate; border-spacing: 0 10px; text-align: left; }\n";
    str += ".data-table th { font-size: 16px; color: #00C853; background: none; border: none; text-align: left; padding-bottom: 10px; font-style: italic; }\n";
    str += ".data-table td { font-size: 14px; color: #bdbdbd; background: #111; border: none; padding: 12px 20px; vertical-align: middle; text-align: left; }\n";
    str += ".data-table tr td:first-child { border-top-left-radius: 4px; border-bottom-left-radius: 4px; }\n";
    str += ".data-table tr td:last-child { border-top-right-radius: 4px; border-bottom-right-radius: 4px; }\n";
    str += ".data-line { font-family: monospace; margin: 10px 0 10px 60px; color: #bdbdbd; background: #111; padding: 10px 15px; border-radius: 4px; display: inline-block; }\n";
    str += "</style>\n</head>\n<body>\n";
    str += "<div class='header'><img class='logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
    
    str += "<div class='main-title'>Thread</div>\n";
    str += "<div class='divider'></div>\n";
    
    const int MaxInformationSize = 256;
    char buff[MaxInformationSize] = {};
    std::string fileName = "Unknown";
    FILE *f = fopen("/proc/self/cmdline", "r");
    if (f != NULL) {
        char readc;
        int i = 0;
        while (((readc = fgetc(f)) != EOF)) {
            if (readc == '\0') {
                buff[i++] = ' ';
            } else {
                buff[i++] = readc;
            }
        }
        fclose(f);
        fileName = strtok(buff, "\n");
    }
    str += "<div class='system-info'>\n";
    str += "  <div class='info-row'>\n";
    str += "    <div class='info-label'>Program Name:</div>\n";
    str += "    <div class='info-value'>" + fileName + "</div>\n";
    str += "  </div>\n";
    str += "</div>\n";
    
    std::ostringstream taskOss;
    MagicSingleton<ProtobufDispatcher>::GetInstance()->TaskInfo(taskOss);
    std::string taskInfo = taskOss.str();
    
    std::vector<std::pair<std::string, size_t>> queueInfos = {
        {"Read Queue", global::g_queueRead.msgQueue.size()},
        {"Work Queue", global::g_queueWork.msgQueue.size()},
        {"Write Queue", global::g_queueWrite.msgQueue.size()}
    };

    str += "<div class='task-grid-title'>Thread Task Statistics</div>\n";
    str += "<div class='task-grid'>\n";
    
    std::map<std::string, std::vector<std::pair<std::string, std::string>>> taskGroups;

    std::istringstream taskStream(taskInfo);
    std::string line;
    std::string currentCategory = "";
    
    while (std::getline(taskStream, line)) {
        if (line.empty() || line.find("===") != std::string::npos) {
            continue;
        }
        
        size_t colonPos = line.find(":");
        if (colonPos != std::string::npos) {
            std::string taskName = line.substr(0, colonPos);
            std::string taskValue = line.substr(colonPos + 1);
            
            size_t underscorePos = taskName.find("_");
            if (underscorePos != std::string::npos) {
                std::string category = taskName.substr(0, underscorePos);
                
                std::string taskType;
                if (taskName.find("active") != std::string::npos) {
                    taskType = "Active Tasks";
                } else if (taskName.find("pending") != std::string::npos) {
                    taskType = "Pending Tasks";
                } else {
                    taskType = "Other";
                }
                
                // 
                taskGroups[category].push_back({taskType, taskValue});
            }
        }
    }
    
    // 
    for (const auto& group : taskGroups) {
        str += "<div class='task-card'>\n";
        str += "  <div class='task-title'>" + group.first + " Module</div>\n";
        
        for (const auto& task : group.second) {
            str += "  <div class='task-value'>";
            str += task.first + ": ";
            if (task.second == "0") {
                str += "<span class='task-zero'>" + task.second + "</span>";
            } else {
                str += "<strong>" + task.second + "</strong>";
            }
            str += "</div>\n";
        }
        
        str += "</div>\n";
    }
    
    // 
    str += "<div class='task-card'>\n";
    str += "  <div class='task-title'>Queue Status</div>\n";
    
    for (const auto& queue : queueInfos) {
        str += "  <div class='task-value'>";
        str += queue.first + ": ";
        if (queue.second == 0) {
            str += "<span class='task-zero'>" + std::to_string(queue.second) + "</span>";
        } else {
            str += "<strong>" + std::to_string(queue.second) + "</strong>";
        }
        str += "</div>\n";
    }
    
    str += "</div>\n";
    str += "</div>\n"; // task-grid
    
    // Request
    str += "<div class='main-title'>Request</div>\n";
    str += "<div class='divider'></div>\n";
    
    // 
    str += "<div class='task-grid-title'>Request Statistics</div>\n";
    str += "<table class='data-table'>\n";
    str += "<thead>\n";
    str += "<tr><th>Request Type</th><th>Count</th><th>Data Size</th></tr>\n";
    str += "</thead>\n<tbody>\n";
    
    double total = .0f;
    uint64_t n64Count = 0;
    
    for (auto &item : global::g_reqCntMap) {
        total += (double)item.second.second; // data size
        str += "<tr>";
        str += "<td>" + item.first + "</td>";
        str += "<td>" + std::to_string(item.second.first) + "</td>";
        
        std::ostringstream sizeStream;
        sizeStream.precision(3);
        sizeStream << (double)item.second.second / 1024 / 1024 << " MB";
        str += "<td>" + sizeStream.str() + "</td>";
        str += "</tr>\n";
        
        n64Count += item.second.first;
    }
    str += "</tbody></table>\n";
    
    // 
    str += "<div class='system-info' style='margin-top: 15px;'>\n";
    str += "  <div class='info-row'>\n";
    str += "    <div class='info-label'>Total Requests:</div>\n";
    str += "    <div class='info-value'>" + std::to_string(n64Count) + "</div>\n";
    str += "  </div>\n";
    str += "  <div class='info-row'>\n";
    str += "    <div class='info-label'>Total Data Size:</div>\n";
    
    std::ostringstream totalSizeStream;
    totalSizeStream.precision(3);
    totalSizeStream << (double)total / 1024 / 1024 << " MB";
    
    str += "    <div class='info-value'>" + totalSizeStream.str() + "</div>\n";
    str += "  </div>\n";
    str += "</div>\n";
    
    str += "<div class='footer'><img class='footer-logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
    str += "</body>\n</html>";
    res.set_content(str, "text/html");
}

// ... existing code ...
// 
void _ApiAccount(const Request &req, Response &res)
{
    std::string str;
    str = "<!DOCTYPE html>\n<html>\n<head>\n";
    str += "<meta charset='UTF-8'>\n";
    str += "<title>MeMeChain Account Info</title>\n";
    str += "<style>\n";
    str += "body { background: #000; color: #fff; font-family: 'Arial', sans-serif; margin: 0; padding: 0; }\n";
    str += ".header { display: flex; align-items: center; padding: 30px 0 0 60px; }\n";
    str += ".logo-img { height: 48px; }\n";
    str += ".footer { position: fixed; left: 0; bottom: 0; width: 100%; height: 80px; background: #111; border-top: 2px solid #222; display: flex; align-items: center; z-index: 10; }\n";
    str += ".footer-logo-img { height: 48px; margin-left: auto; margin-right: 20%; }\n";
    str += ".main-title { margin-left: 60px; margin-top: 20px; font-size: 22px; color: #fff; font-weight: 500; text-align: left; font-style: italic; }\n";
    str += ".divider { width: 90%; min-width: 400px; margin: 18px 0 0 60px; border-bottom: 2px solid #222; text-align: left; }\n";
    
    // Account
    str += ".task-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; width: 90%; margin: 20px 0 30px 60px; }\n";
    str += ".task-card { background: #111; border-radius: 6px; padding: 15px; border-left: 3px solid #444; transition: all 0.3s ease; }\n";
    str += ".task-card:hover { border-left-color: #00A046; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); }\n";
    str += ".task-title { color: #00C853; font-weight: bold; margin-bottom: 8px; font-size: 14px; }\n";
    str += ".task-value { color: #bdbdbd; font-family: monospace; font-size: 13px; }\n";
    str += ".task-zero { color: #555; }\n";
    str += ".task-grid-title { color: #888; margin: 5px 0 15px 60px; font-size: 16px; font-style: italic; }\n";
    str += ".system-info { background: #111; border-radius: 6px; padding: 15px; margin: 0 0 20px 60px; width: 90%; max-width: 1200px; }\n";
    str += ".info-row { display: flex; margin-bottom: 10px; }\n";
    str += ".info-label { color: #00C853; width: 130px; font-weight: bold; }\n";
    str += ".info-value { color: #bdbdbd; font-family: monospace; flex-grow: 1; }\n";
    str += ".section-gap { margin-top: 30px; }\n";
    
    // 
    str += ".data-table { width: 90%; min-width: 400px; margin: 20px 0 80px 60px; border-collapse: separate; border-spacing: 0 10px; text-align: left; }\n";
    str += ".data-table th { font-size: 16px; color: #00C853; background: none; border: none; text-align: left; padding-bottom: 10px; font-style: italic; }\n";
    str += ".data-table td { font-size: 14px; color: #bdbdbd; background: #111; border: none; padding: 12px 20px; vertical-align: middle; text-align: left; }\n";
    str += ".data-table tr td:first-child { border-top-left-radius: 4px; border-bottom-left-radius: 4px; }\n";
    str += ".data-table tr td:last-child { border-top-right-radius: 4px; border-bottom-right-radius: 4px; }\n";
    str += ".data-line { font-family: monospace; margin: 10px 0 10px 60px; color: #bdbdbd; background: #111; padding: 10px 15px; border-radius: 4px; display: inline-block; }\n";
    str += "</style>\n</head>\n<body>\n";
    str += "<div class='header'><img class='logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
    
    // Account
    str += "<div class='main-title'>Account</div>\n";
    str += "<div class='divider'></div>\n";
    
    // 
    uint64_t totalVoteAssets = 0;
    uint64_t totalMMC = 0;
    
    // 
    str += "<div class='task-grid-title'>Account Information</div>\n";
    str += "<table class='data-table'>\n";
    str += "<thead>\n";
    str += "<tr><th>Account Address</th><th>Assets</th></tr>\n";
    str += "</thead>\n<tbody>\n";
    
    std::vector<std::string> baseList;
    MagicSingleton<accountManager>::GetInstance()->GetAccountList(baseList);
    
    if (baseList.empty()) {
        // ,
        str += "<tr><td colspan='2' style='text-align:center;'>No account data available</td></tr>\n";
    } else {
        // 
        for (auto &i : baseList) {
            int64_t voteAmount = 0;
            int64_t mmcAmount = 0;
            
            // GetBalanceByUtxo(i, global::ca::ballotAssetType, voteAmount);
            // // MMC
            std::string assetType;
            int ret = ca_algorithm::GetCanBeRevokeAssetType(assetType);
            if(ret != 0){
                ERRORLOG("Get Can BeRevoke AssetType fail!");
            }

            DBReader dbReader;
            dbReader.GetBalanceByAddress(i, global::ca::ballotAssetType, voteAmount);
            double v = voteAmount / double(100000000);
            dbReader.GetBalanceByAddress(i, assetType, mmcAmount);
            double m = mmcAmount / double(100000000);

            uint64_t blockHeight = 0;
            dbReader.GetBlockTop(blockHeight);

            totalVoteAssets += voteAmount;
            totalMMC += mmcAmount;

             
            str += "<tr>";
            str += "<td><span style='font-family:monospace;'>0x" + i + "</span></td>";
            str += "<td>\n";
            str += "  <div style='display:flex; flex-direction:column; gap:8px;'>\n";
            str += "    <div><span style='color:#00C853; font-weight:500;'>Vote Assets:</span> " + std::to_string(v) + "</div>\n";
            str += "    <div><span style='color:#00C853; font-weight:500;'>MMC Balance:</span> " + std::to_string(m) + "</div>\n";
            // 
            // str += "    <div><span style='color:#00C853; font-weight:500;'>Asset Type X:</span> value</div>\n";
            // str += "    <div><span style='color:#00C853; font-weight:500;'>Asset Type Y:</span> value</div>\n";
            str += "  </div>\n";
            str += "</td>";
            str += "</tr>\n";
        }
    }
    
    str += "</tbody></table>\n";
    
    // 
    str += "<div class='system-info' style='margin-top: 15px;'>\n";
    str += "  <div class='info-row'>\n";
    str += "    <div class='info-label'>Total Accounts:</div>\n";
    str += "    <div class='info-value'>" + std::to_string(baseList.size()) + "</div>\n";
    str += "  </div>\n";
    str += "</div>\n";
    
    str += "<div class='footer'><img class='footer-logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
    str += "</body>\n</html>";
    res.set_content(str, "text/html");
}

void _ApiNode(const Request &req, Response &res)
{
    std::vector<Node> pubNodeList = MagicSingleton<PeerNode>::GetInstance()->GetNodelist();
    std::string str;
    str = "<!DOCTYPE html>\n<html>\n<head>\n";
    str += "<meta charset='UTF-8'>\n";
    str += "<title>MeMeChain Node List</title>\n";
    str += "<style>\n";
    str += "body { background: #000; color: #fff; font-family: Arial, sans-serif; margin: 0; padding: 0; }\n";
    str += ".header { display: flex; align-items: center; padding: 30px 0 0 60px; }\n";
    str += ".logo-img { height: 48px; }\n";
    str += ".footer { position: fixed; left: 0; bottom: 0; width: 100%; height: 80px; background: #111; border-top: 2px solid #222; display: flex; align-items: center; z-index: 10; }\n";
    str += ".footer-logo-img { height: 48px; margin-left: auto; margin-right: 20%; }\n";
    str += ".main-title { margin-left: 60px; margin-top: 20px; font-size: 22px; color: #fff; font-weight: 500; text-align: left; font-style: italic; }\n";
    str += ".divider { width: 90%; min-width: 400px; margin: 18px 0 0 60px; border-bottom: 2px solid #222; text-align: left; }\n";
    str += ".node-table { width: 90%; min-width: 400px; margin: 20px 0 80px 60px; border-collapse: separate; border-spacing: 0 10px; text-align: left; }\n";
    str += ".node-table th { font-size: 18px; color: #fff; background: none; border: none; text-align: left; padding-bottom: 10px; font-style: italic; }\n";
    str += ".node-table th:nth-child(1) { width: 350px; }\n"; 
    str += ".node-table { table-layout: fixed; }\n";
    str += ".node-table th { padding-left: 40px; }\n";
    str += ".node-table th:first-child { padding-left: 0; }\n";
    str += ".node-table td { font-size: 16px; color: #fff; background: none; border: none; padding: 6px 0 6px 40px; vertical-align: middle; text-align: left; font-style: normal; }\n";
    str += ".node-table td:first-child { padding-left: 0; width: 350px; }\n";
    str += ".node-table .addr { font-size: 14px; color: #bdbdbd; }\n";
    str += ".node-table .logo-cell { height: 32px; }\n";
    str += ".node-table .logo-img-cell { height: 32px; }\n";
    str += "</style>\n</head>\n<body>\n";
    str += "<div class='header'><img class='logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
    str += "<div class='main-title'>Node List</div>\n";
    str += "<div class='divider'></div>\n";
    str += "<div style='margin-left:60px;margin-top:10px;font-size:16px;'>Public PeerNode size is:" + std::to_string(pubNodeList.size()) + "</div>\n";
    str += "<table class='node-table'>\n<thead><tr>";
    str += "<th>Addr</th><th>Ip</th><th>Height</th><th>Port</th><th>Kind</th><th>Fd</th><th>Pulse</th><th>Version</th>";
    str += "</tr></thead>\n<tbody>\n";
    for (const auto& node : pubNodeList) {
        str += "<tr>";
        str += "<td class='addr'>0x" + node.address + "</td>";
        str += "<td>" + std::string(IpPort::IpSz(node.publicIp)) + "</td>";
        str += "<td>" + std::to_string(node.height) + "</td>";
        str += "<td>" + std::to_string(node.publicPort) + "</td>";
        str += "<td>" + std::to_string(node.connKind) + "</td>";
        str += "<td>" + std::to_string(node.fd) + "</td>";
        str += "<td>" + std::to_string(node.pulse) + "</td>";
        str += "<td>" + node.ver + "</td>";
        str += "</tr>\n";
    }
    str += "</tbody></table>\n";
    str += "<div class='footer'><img class='footer-logo-img' src='" + MEMECHAIN_LOGO_BASE64 + "' alt='MeMeChain Logo'></div>\n";
    str += "</body>\n</html>";
    res.set_content(str, "text/html");
}
// ... existing code ... 

void _GetRequesterIP(const Request &req, Response & res){
    std::ostringstream oss;
    std::string ip = req.remote_addr;
    oss << ip;
    res.set_content(oss.str(), "application/json");
}


void _ApiPrintCalc1000SumHash(const Request &req,Response &res)
{
    int startHeight = 1000;
    if (req.has_param("startHeight")) {
        startHeight = atol(req.get_param_value("startHeight").c_str());
    }
    if(startHeight <= 0 || startHeight % 1000 != 0)
    {
        res.set_content("startHeight error", "text/plain");
        return;
    }

    int endHeight = 0;
    if (req.has_param("endHeight")) {
        endHeight = atol(req.get_param_value("endHeight").c_str());
    }

    if(endHeight < startHeight || endHeight % 1000 != 0)
    {
        res.set_content("endHeight error", "text/plain");
        return;
    }

    uint64_t max_height = 0;
    DBReader dbReader;
    if(DBStatus::DB_SUCCESS != dbReader.GetTopThousandSumhash(max_height))
    {
        res.set_content("GetBlockComHashHeight error", "text/plain");
        return;
    }

    std::ostringstream oss;
    if(max_height < endHeight)
    {
        endHeight = max_height;
        oss << "max_height = " << max_height << std::endl;
    }


    for(int i = startHeight; i <= endHeight; i += 1000)
    {
        std::string sumHash;
        auto ret = dbReader.GetCheckBlockHashsByBlockHeight(i, sumHash);
        if(ret == DBStatus::DB_SUCCESS)
        {
            oss << "blockHeight: " << i << "\t sumHash: " << sumHash << std::endl;
        }
        else 
        {
            oss << "GetCheckBlockHashsByBlockHeight error" << std::endl;
        }
        
    }


    res.set_content(oss.str(), "text/plain");

}

void _ApiPrintHundredSumHash(const Request & req, Response & res)
{
    int startHeight = 100;
    if (req.has_param("startHeight")) {
        startHeight = atol(req.get_param_value("startHeight").c_str());
    }
    if(startHeight <= 0 || startHeight % 100 != 0)
    {
        res.set_content("startHeight error", "text/plain");
        return;
    }

    int endHeight = 0;
    if (req.has_param("endHeight")) {
        endHeight = atol(req.get_param_value("endHeight").c_str());
    }

    if(endHeight < startHeight || endHeight % 100 != 0)
    {
        res.set_content("endHeight error", "text/plain");
        return;
    }

    DBReader dbReader;
    std::ostringstream oss;

    for(int i = startHeight; i <= endHeight; i += 100)
    {
        std::string sumHash;
        auto ret = dbReader.GetSumHashByHeight(i, sumHash);
        if(ret == DBStatus::DB_SUCCESS)
        {
            oss << "blockHeight: " << i << "\t sumHash: " << sumHash << std::endl;
        }
        else 
        {
            oss << "GetSumHashByHeight error, error height: " << i << std::endl;
        }
        
    }
    
    res.set_content(oss.str(), "text/plain");
}

void _ApiPrintAllBlocks(const Request &req,Response &res)
{
    int startHeight = 1;
    if (req.has_param("startHeight")) {
        startHeight = atol(req.get_param_value("startHeight").c_str());
    }
    if(startHeight <= 0)
    {
        res.set_content("error startHeight <= 0", "text/plain");
        return;
    }

    int endHeight = 0;
    if (req.has_param("endHeight")) {
        endHeight = atol(req.get_param_value("endHeight").c_str());
    }

    uint64_t selfNodeHeight = 0;
    DBReader dbReader;
    auto status = dbReader.GetBlockTop(selfNodeHeight);
    if (DBStatus::DB_SUCCESS != status)
    {
        res.set_content("GetBlockTop error", "text/plain");
        return;
    }

    if(endHeight > selfNodeHeight)
    {
        res.set_content("endHeight > selfNodeHeight", "text/plain");
        return;
    }

    std::stringstream oss;
    oss << "block_hash_" << startHeight << "_" << endHeight << ".txt";
    std::ofstream fout(oss.str(), std::ios::out);
    for(int i = startHeight; i <= endHeight; ++i)
    {
        std::vector<std::string> selfBlockHashes;
        if (DBStatus::DB_SUCCESS != dbReader.FetchBlockHashesInRange(i, i, selfBlockHashes))
        {
            res.set_content("FetchBlockHashesInRange error", "text/plain");
            return;
        }
        std::sort(selfBlockHashes.begin(), selfBlockHashes.end());
        fout << "block height: " << i << "\tblock size: " << selfBlockHashes.size() << std::endl; 
        for(const auto& hash: selfBlockHashes)
        {
            std::string strHeader;
            if (DBStatus::DB_SUCCESS != dbReader.GetBlockByBlockHash(hash, strHeader)) 
            {
                res.set_content("GetBlockByBlockHash error", "text/plain");
                return;
            }

            CBlock block;
            if(!block.ParseFromString(strHeader))
            {
                res.set_content("ParseFromString error", "text/plain");
                return;
            }
            fout << block.hash() << std::endl;
        }
        fout << "==============================================\n\n";

    }

    res.set_content("print success", "text/plain");

}

int PrintProposalInfo(DBReadWriter &db, const std::string &type, std::ostringstream &oss)
{
    // Helper function for field rows
    auto add_field = [&](const std::string &label, const auto &value)
    {
        oss
            << "<div class=\"field-row\">"
            << "<span class=\"field-label\">" << label << "</span>"
            << "<span class=\"field-value\">" << value << "</span>"
            << "</div>";
    };

    // Helper function for address groups
    auto add_address_group = [&](const std::set<std::string> &addresses,
                                 const std::string &type,
                                 const std::string &title)
    {
        oss << "<div class=\"address-group " << type << "\">"
            << "<div class=\"group-header\">"
            << "<span>" << title << "</span>"
            << "<span class=\"count\">" << addresses.size() << "</span>"
            << "</div>" // group-header
            << "<div class=\"address-list\">";

        for (const auto &addr : addresses)
        {
            oss << "<span class=\"address-item\">" << addr.substr(0, 6) << "</span>";
        }

        oss << "</div></div>"; // address-list  address-group
    };

    // Main proposal card
    oss << "<div class=\"proposal-card\">"
        << "<div class=\"proposal-header\">"
        << "<div class=\"section-title\">Proposal Transaction</div>"
        << "<div class=\"hash-display\">"
        << "<span class=\"hash-label\">Proposal Hash:</span>"
        << "<span class=\"hash-value\">" << addHexPrefix(type) << "</span>"
        << "</div></div>" // hash-display  proposal-header
        << "<div class=\"proposal-body\">"
        << "<div class=\"info-section\">"
        << "<div class=\"section-title\">Basic Information</div>";

    // Basic info fields
    Base64 base;
    std::string info;
    if (auto dbRet = db.GetAssetInfobyAssetType(type, info); dbRet == DBStatus::DB_SUCCESS)
    {
        std::string decode = base.Decode(info.c_str(), info.size());
        auto dataJson = nlohmann::json::parse(decode);
        std::string decodeName = dataJson["Name"].get<std::string>();
        std::string decodeTitle = dataJson["Title"].get<std::string>();
        std::string decodeIdentifier = dataJson["Identifier"].get<std::string>();
        add_field("Asset Name:", base.Decode(decodeName.c_str(), decodeName.size()));
        add_field("Version:", dataJson["Version"].get<int>());
        add_field("BeginTime:", ca_algorithm::ConversionTime(dataJson["BeginTime"].get<uint64_t>()));
        add_field("EndTime:", ca_algorithm::ConversionTime(dataJson["EndTime"].get<uint64_t>()));
        add_field("ExpirationDate:", dataJson["ExpirationDate"].get<uint64_t>());
        add_field("ExchangeRate:", dataJson["ExchangeRate"].get<std::string>());
        add_field("ContractAddress:", addHexPrefix(dataJson["ContractAddr"].get<std::string>()));
        add_field("CanBeStake:", dataJson["CanBeStake"].get<uint64_t>());
        add_field("MinVoteNum:", dataJson["MinVoteNum"].get<uint64_t>());
        add_field("Title:", base.Decode(decodeTitle.c_str(), decodeTitle.size()));
        add_field("Identifier:", base.Decode(decodeIdentifier.c_str(), decodeIdentifier.size()));
    }
    else
    {
        ERRORLOG("GetAssetInfobyAssetType error: {}", dbRet);
        return -1;
    }

    oss << "</div>" // 
        << "<div class=\"voting-section\">"
        << "<div class=\"section-title\">Voting Status</div>";

    // Voting info
    std::string voteCount;
    if (auto dbRet = db.GetVoteNumByAssetHash(type, voteCount); dbRet == DBStatus::DB_SUCCESS)
    {
        add_field("CurrentVotes:", voteCount);
    }
    else
    {
        ERRORLOG("GetVoteNumByAssetHash error: {}", dbRet);
        return -2;
    }

    // Address groups
    std::set<std::string> addresses;
    if (auto dbRet = db.GetApproveAddrsByAssetHash(type, addresses);
        dbRet == DBStatus::DB_SUCCESS || dbRet == DBStatus::DB_NOT_FOUND)
    {
        add_address_group(addresses, "approve", "Approved Addresses:");
    }
    else
    {
        ERRORLOG("GetApproveAddrs error: {}", dbRet);
        return -3;
    }

    addresses.clear();
    if (auto dbRet = db.GetAgainstAddrsByAssetHash(type, addresses);
        dbRet == DBStatus::DB_SUCCESS || dbRet == DBStatus::DB_NOT_FOUND)
    {
        add_address_group(addresses, "against", "Against Addresses:");
    }
    else
    {
        ERRORLOG("GetAgainstAddrs error: {}", dbRet);
        return -4;
    }

    // 
    oss << "</div></div></div>";

    // 
    std::vector<std::string> revokeHashes;
    if (auto dbRet = db.GetRevokeTxHashByAssetType(type, revokeHashes); dbRet == DBStatus::DB_SUCCESS)
    {
        oss << "<div class='proposal-card revoked-card'>"
            << "<div class='revoked-header'>"
            << "<div class=\"section-title\">Revoke Proposal Transactions</div>"
            << "<div class='revoked-section'>"
            << "<div class='hash-display'>"
            << "</div>";                          // hash-display

        for (const auto &hash : revokeHashes)
        {                                             // revoked-header
            if (std::string revokeInfo; db.GetRevokeProposalInfobyTxHash(hash, revokeInfo) == DBStatus::DB_SUCCESS)
            {
                auto decoded = base.Decode(revokeInfo.c_str(), revokeInfo.size());
                auto revokeJson = nlohmann::json::parse(decoded);

                oss << "<div class='revoked-details'>"
                    << "<div class='detail-group'>"
                    << "<div class='hash-display'>"
                    << "<span class='hash-label'>RevokeProposalHash:</span>"
                    << "<span class='hash-value'>" << addHexPrefix(hash) << "</span>"
                    << "</div>" // hash-display
                    << "<div class='section-title'>Basic Information</div>";

                add_field("OriginalProposal:", addHexPrefix(revokeJson["ProposalHash"].get<std::string>()));
                add_field("Version:", revokeJson["Version"].get<int>());
                add_field("BeginTime:", ca_algorithm::ConversionTime(revokeJson["BeginTime"].get<uint64_t>()));
                add_field("EndTime:", ca_algorithm::ConversionTime(revokeJson["EndTime"].get<uint64_t>()));
                add_field("MinVoteNum:", revokeJson["MinVoteNum"].get<uint64_t>());

                oss << "</div></div>" // detail-group  revoked-details
                    << "<div class='voting-section'>"
                    << "<div class='section-title'>Voting Status</div>"
                    << "</div>"; // voting-section
            }

            std::string voteCount;
            if (auto dbRet = db.GetVoteNumByAssetHash(type, voteCount); dbRet == DBStatus::DB_SUCCESS)
            {
                add_field("CurrentVotes:", voteCount);
            }
            else
            {
                ERRORLOG("GetVoteNumByAssetHash error: {}", dbRet);
                return -3;
            }

            // Address groups
            std::set<std::string> addresses;
            if (auto dbRet = db.GetApproveAddrsByAssetHash(type, addresses);
                dbRet == DBStatus::DB_SUCCESS || dbRet == DBStatus::DB_NOT_FOUND)
            {
                add_address_group(addresses, "approve", "Approved Addresses:");
            }
            else
            {
                ERRORLOG("GetApproveAddrs error: {}", dbRet);
                return -4;
            }

            addresses.clear();
            if (auto dbRet = db.GetAgainstAddrsByAssetHash(type, addresses);
                dbRet == DBStatus::DB_SUCCESS || dbRet == DBStatus::DB_NOT_FOUND)
            {
                add_address_group(addresses, "against", "Against Addresses:");
            }
            else
            {
                ERRORLOG("GetAgainstAddrs error: {}", dbRet);
                return -5;
            }
        }
        oss << "</div></div></div>"; // revoked-section, revoked-header, proposal-card
        oss << "</div>";             // revoked-item;
    }

    // Close main containers
    oss << "</div></div></div>";

    return 0;
}

void _ApiPrintVoteInfo(const Request &req,Response &res)
{
    DBReadWriter db;
    std::ostringstream error;
    std::vector<std::string> assetType;
    auto dbRet = db.GetAllAssetType(assetType);
    if(DBStatus::DB_SUCCESS != dbRet)
    {
        error << "GetAllAssetType error, error num: " << dbRet << std::endl;
        res.set_content(error.str(), "text/plain");
        return;
    }
    std::ostringstream oss;

    // HTML Document Structure
    oss << "<!DOCTYPE html>\n"
        << "<html>\n<head>\n"
        << "<meta charset=\"UTF-8\">\n"
        << "<title>Proposal Details</title>\n"
        << "<style>\n";

    // CSS Variables
    oss << ":root {\n"
        << "  --primary: #2ECC71;\n"
        << "  --text-label: #FFFFFF;\n"
        << "  --text-key: #FFFFFF;\n"
        << "  --text-value: #FFFFFF;\n"
        << "  --card-bg: #1E1E1E;\n"
        << "  --border-radius: 8px;\n"
        << "}\n\n";

    // Base Styles
    oss << "body {\n"
        << "  background: #121212;\n"
        << "  color: white;\n"
        << "  font-family: 'Segoe UI', sans-serif;\n"
        << "  margin: 0;\n"
        << "  padding: 2rem;\n"
        << "}\n\n";

    // Brand Header
    oss << ".brand-header {\n"
        << "  display: flex;\n"
        << "  align-items: center;\n"
        << "  margin-bottom: 2.5rem;\n"
        << "  width: 200px;\n"
        << "  height: 40px;\n"
        << "  background-image: url('" << MEMECHAIN_LOGO_BASE64 << "');\n"
        << "  background-size: contain;\n"
        << "  background-repeat: no-repeat;\n"
        << "}\n\n";

    // Proposal Card
    oss << ".proposal-card {\n"
        << "  background: var(--card-bg);\n"
        << "  border-radius: var(--border-radius);\n"
        << "  padding: 1.5rem;\n"
        << "  margin-bottom: 1.5rem;\n"
        << "  box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n"
        << "}\n\n";

    // Field Layout
    oss << ".field-row {\n"
        << "  display: grid;\n"
        << "  grid-template-columns: 160px 1fr;\n"
        << "  align-items: baseline;\n"
        << "  margin: 8px 0;\n"
        << "}\n\n"
        << ".field-label {\n"
        << "  color: var(--text-label);\n"
        << "  font-family: 'Segoe UI', sans-serif;\n"
        << "  font-size: 14px;\n"
        << "  text-align: left;\n"
        << "  padding-right: 12px;\n"
        << "}\n\n"
        << ".field-value {\n"
        << "  color: var(--text-value);\n"
        << "  font-family: 'Segoe UI', sans-serif;\n"
        << "  font-size: 14px;\n"
        << "  font-weight: 500;\n"
        << "  word-break: break-word;\n"
        << "  padding-left: 2px;\n"
        << "}\n\n";

    // Address Groups
    oss << ".address-group {\n"
        << "  margin: 0.8rem 0;\n"
        << "}\n\n"
        << ".group-header {\n"
        << "  display: grid;\n"
        << "  grid-template-columns: 160px 1fr;\n"
        << "  align-items: baseline;\n"
        << "}\n\n"
        << ".group-header > span:first-child {\n"
        << "  color: #FFF;\n"
        << "  font-family: 'Segoe UI', sans-serif;\n"
        << "  font-size: 14px;\n"
        << "  font-weight: 500;\n"
        << "  padding-right: 12px;\n"
        << "}\n\n"
        << ".count {\n"
        << "  color: #FFF;\n"
        << "  font-family: 'Segoe UI', sans-serif;\n"
        << "  font-size: 14px;\n"
        << "  font-weight: 500;\n"
        << "}\n\n"
        << ".address-list {\n"
        << "  margin-left: 160px;\n"
        << "  display: flex;\n"
        << "  gap: 8px;\n"
        << "  flex-wrap: wrap;\n"
        << "  margin-top: 4px;\n"
        << "}\n\n"
        << ".address-item {\n"
        << "  color: #FFF;\n"
        << "  font-family: monospace;\n"
        << "  background: rgba(46, 204, 113, 0.1);\n"
        << "  padding: 2px 8px;\n"
        << "  border-radius: 4px;\n"
        << "  border: 1px solid #2ECC71;\n"
        << "}\n\n";

    // Special Sections
    oss << ".voting-section .section-title {\n"
        << "  color: var(--text-label);\n"
        << "  font-size: 16px;\n"
        << "  margin: 20px 0 12px;\n"
        << "}\n\n"
        << ".timestamp {\n"
        << "  color: var(--primary);\n"
        << "  font-family: monospace;\n"
        << "}\n\n";

    // Close Styles
    oss << "</style>\n</head>\n<body>\n"
        << "<div class=\"brand-header\">\n"
        << "  <div class=\"logo-icon\"></div>\n"
        << "</div>\n"
        << "<h2>Proposal Details</h2>\n";
    for (const auto &type : assetType)
    {
        //oss << "=====================================================================\n";
        int ret = PrintProposalInfo(db, type, oss);
        if(ret != 0)
        {
            error << "PrintProposalInfo error, error num: " << ret << std::endl;
            res.set_content(error.str(), "text/plain");
            return;
        }
    }

    
    res.set_content(oss.str(), "text/html");
}

void _ApiPrintLockAddrs(const Request &req,Response &res)
{
    DBReadWriter db;
    std::ostringstream oss;

    std::vector<std::string> addresses;
    auto dbRet = db.GetLockAddress(addresses);
    if(dbRet != DB_SUCCESS)
    {
        oss << "GetLockAddress error, error num: " << dbRet << std::endl;
        res.set_content(oss.str(), "text/plain");
        return;
    }

    oss << addresses.size() << std::endl;
    for(const auto& t: addresses)
    {
        oss << "addr: " << t;
        std::vector<std::string> utxos;
        dbRet = db.GetLockAddressUtxo(t, global::ca::ballotAssetType, utxos);
        if(dbRet != DB_SUCCESS)
        {
            oss << "\nGetLockAddressUtxo error, error num: " << dbRet << "error addr: " << t << std::endl;
            res.set_content(oss.str(), "text/plain");
            return;
        }
        for(const auto& utxo: utxos)
        {
            oss << " - " << utxo;
        }
        oss << "\n";
    }

    res.set_content(oss.str(), "text/plain");
}

void _ApiPrintProposalInfo(const Request &req,Response &res)
{
    std::string hash;
    if (req.has_param("hash")) {
        hash = req.get_param_value("hash").c_str();
    }
    if (hash.empty()) {
        res.set_content("get hash error", "text/plain");
        return;
    }

    DBReadWriter db;
    std::ostringstream error;
    std::ostringstream oss;
    int ret = PrintProposalInfo(db, hash, oss);
    if(ret != 0)
    {
        error << "PrintProposalInfo error, error num: " << ret << std::endl;
        res.set_content(error.str(), "text/plain");
        return;
    }

    res.set_content(oss.str(), "text/plain");
}

void _ApiPrintAvailableAssetType(const Request &req,Response &res)
{
    std::map<std::string, TxHelper::ProposalInfo> assetMap;
    int ret = ca_algorithm::GetAvailableAssetType(assetMap);

    if(ret != 0)
    {
        ERRORLOG("GetAvailableAssetType Error");
        return;
    }
    if(assetMap.empty())
    {
        res.set_content("Available asset type is empty", "text/plain");
        return;
    }

    std::ostringstream html;
    html << "<!DOCTYPE html>"
         << "<html>"
         << "<head>"
         << "<style>"
         << "body {"
         << "  background: #121212;"
         << "  color: white;"
         << "  font-family: 'Segoe UI', sans-serif;"
         << "  margin: 0;"
         << "  padding: 2rem;"
         << "}"
         << ".brand-header {"
         << "  display: flex;"
         << "  align-items: center;"
         << "  margin-bottom: 2.5rem;"
         << "  width: 200px;"
         << "  height: 40px;"
         << "  background-image: url('" << MEMECHAIN_LOGO_BASE64 << "');"
         << "  background-size: contain;"
         << "  background-repeat: no-repeat;"
         << "}"
         << ".logo-icon {"
         << "  width: 36px;"
         << "  height: 36px;"
         << "  background: var(--primary);"
         << "  clip-path: path('M12 2 C18 2 24 8 24 14 C24 20 18 26 12 26 C6 26 0 20 0 14 C0 8 6 2 12 2 Z');"
         << "  margin-right: 12px;"
         << "}"
         << ".proposal-card {"
         << "  background: #1E1E1E;"
         << "  border-radius: 8px;"
         << "  padding: 1.5rem;"
         << "  margin-bottom: 1.5rem;"
         << "  box-shadow: 0 4px 6px rgba(0,0,0,0.1);"
         << "}"
         << ".detail-row {"
         << "  display: grid;"
         << "  grid-template-columns: 160px 1fr;"
         << "  gap: 1rem;"
         << "  margin: 0.8rem 0;"
         << "}"
         << ".field-label {"
         << "  color: #FFFFFF;"
         << "  text-align: right;"
         << "  font-size: 0.95rem;"
         << "}"
         << ".field-value {"
         << "  color: #FFF;"
         << "  word-break: break-all;"
         << "  font-weight: 500;"
         << "}"
         << ".field-label {"
         << "  color: #FFF;"
         << "  text-align: right;"
         << "  font-size: 0.95rem;"
         << "  font-weight: 500;"
         << "}"
         << ".timestamp {"
         << "  color: var(--primary);"
         << "  font-family: monospace;"
         << "}"
         << "</style>"
         << "</head>"
         << "<body>"
         << "<div class=\"brand-header\">"
         << "  <div class=\"logo-icon\"></div>"
         << "</div>"
         << "<h2>Proposal Details</h2>";

    if (assetMap.empty())
    {
        html << R"(<div class="proposal-card"><h3 style="color:#FF5555">No available assets</h3></div>)";
    }
    else
    {
        for (const auto &t : assetMap)
        {
            html << R"(<div class="proposal-card"><div class="detail-row">)";
            {
                std::ostringstream oss;
                const auto &proposal = t.second;
                using Field = std::tuple<std::string, std::string, bool>;
                const std::vector<Field> fields = {
                    {"Hash:", addHexPrefix(t.first), false},
                    {"Proposal Type:", proposal.Name, false},
                    {"Exchange Rate:", (oss << proposal.ExchangeRate, oss.str()), false},
                    {"Begin Time:", (oss.str(""), oss << ca_algorithm::ConversionTime(proposal.BeginTime) << "(" << proposal.BeginTime << ")", oss.str()), true},
                    {"End Time:", (oss.str(""), oss << ca_algorithm::ConversionTime(proposal.EndTime) << "(" << proposal.EndTime << ")", oss.str()), true},
                    {"Contract Address:", addHexPrefix(proposal.ContractAddr), false},
                    {"CanBeStake:", (oss.str(""), oss << std::boolalpha << proposal.CanBeStake, oss.str()), false},
                    {"MinVoteNum:", (oss.str(""), oss << proposal.MinVoteNum, oss.str()), false}};

                for (const auto &[label, value, space] : fields)
                {
                    html << R"(<div class="field-label">)" << label
                         << R"(</div><div class="field-value)"
                         << (space ? " " : "") << R"(">)" << value << R"(</div>)";
                }
            }
            html << R"(</div></div>)";
        }
    }
    html << R"(</body></html>)";

    res.set_content(html.str(), "text/html");
}

void _ApiGetAsseTypeByContractAddr(const Request &req,Response &res)
{
    std::string contractAddr;
    if (req.has_param("contractAddr")) 
    {
        contractAddr = req.get_param_value("contractAddr").c_str();
    }
    if (contractAddr.empty()) 
    {
        res.set_content("get contractAddr error", "text/plain");
        return;
    }

    std::string assetType;
    int ret = ca_algorithm::GetAsseTypeByContractAddr(contractAddr, assetType);
    if(ret == 0)
    {
        res.set_content(assetType, "text/plain");
    }
    else
    {
        std::ostringstream oss;
        oss << "GetContractAddrByAsseType error, error num: " << ret;
        res.set_content(oss.str(), "text/plain");
    }

    return;
}

void _GetLock(const Request &req,Response &res)
{
    getLockReq req_t;
    txAck ack_t;

    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateLockTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    std::string fromAddr = req_t.fromAddr;
    if (fromAddr.substr(0, 2) == "0x") 
    {
        fromAddr = fromAddr.substr(2);
    }

    int32_t lockType = std::stoll(req_t.LockType);

    std::regex pattern("^[1-9]\\d*$"); 
    if(!std::regex_match(req_t.lockAmount, pattern))
    {
        ack_t.code = -18;
        ack_t.message = "LockAmount format error";
        return res.set_content(ack_t._parseToString(), "application/json");;
    }
    uint64_t lockAmount = std::stoll(req_t.lockAmount);

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    std::pair<std::string,std::string> gastrade = req_t.gastrade ;
    gastrade.first = remove0xPrefix(gastrade.first);
    gastrade.second = remove0xPrefix(gastrade.second);
    bool isGasTrade = req_t.isGasTrade ; 

    ReplaceCreateLockTransaction(fromAddr, lockAmount * global::ca::kDecimalNum, lockType, gastrade,isGasTrade, isFindUtxoFlag, encodedInfo, &ack_t);

    res.set_content(ack_t._parseToString(), "application/json");
}


void _GetLockUtxo(const Request & req, Response & res)
{
    getLockutxoAck ack_t;
    getLockutxoReq req_t;

    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetLockUtxo";

    std::string strFromAddr = req_t.fromAddr;
    if (strFromAddr.substr(0, 2) == "0x") 
    {
        strFromAddr = strFromAddr.substr(2);
    }

    DBReader dbReader;
    std::vector<std::string> utxos;
    auto ret = dbReader.GetLockAddressUtxo(strFromAddr, global::ca::ballotAssetType ,utxos);
    if(ret != DBStatus::DB_SUCCESS)
    {
        ack_t.code = -1;
        ack_t.message = "fromaddr not lock!";
    }

    for (auto &utxo : utxos) {
        
        std::string txRaw;
        if(DBStatus::DB_SUCCESS != dbReader.GetTransactionByHash(utxo, txRaw))
        {
            ack_t.code = -2;
            ack_t.message = "get transaction error";
        }
        CTransaction tx;
        if(!tx.ParseFromString(txRaw))
        {
            ack_t.code = -3;
            ack_t.message = "parse transaction error";
        }
        uint64_t value = 0;
        for(const auto & txUtxo : tx.utxos())
        {
            for (auto &vout : txUtxo.vout()) 
            {
                if (vout.addr() == global::ca::kLockVirtualAddr) 
                {
                    value = vout.value();
                }
                ack_t.utxos.first = utxo;
                ack_t.utxos.second = value;
            }
        }
    }

    ack_t.code = 0;
    ack_t.message = "success";
    res.set_content(ack_t._parseToString(), "application/json");
    DEBUGLOG("http_api.cpp:GetStakingUtxo ack_T.parseToString{}",ack_t._parseToString());
}
void _GetUnLock(const Request & req, Response & res)
{
    getUnLockReq req_t;
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateUnLockTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    std::string fromAddr = req_t.fromAddr;
    if (fromAddr.substr(0, 2) == "0x") 
    {
        fromAddr = fromAddr.substr(2);
    }
    
    std::string utxoHash = req_t.utxoHash;

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    std::pair<std::string,std::string> gastrade = req_t.gastrade ;
    gastrade.first = remove0xPrefix(gastrade.first);
    gastrade.second = remove0xPrefix(gastrade.second);
    bool isGasTrade = req_t.isGasTrade ; 
    ReplaceCreateUnLockTransaction(fromAddr, utxoHash,gastrade,isGasTrade, isFindUtxoFlag, encodedInfo, &ack_t);
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetProposal(const Request & req, Response & res)
{
    GetProposalReq req_t;
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateProposalTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    const std::regex pattern(R"(-?\d+(\.\d)?\b)");
    if (!std::regex_match(req_t.duration, pattern))
    {
        ERRORLOG("GetProposal input duration error");
        ack_t.code = -100;
        ack_t.message = "input duration error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    double time = 0;
    try 
    {
        time = std::stod(req_t.duration);
    } 
    catch (const std::invalid_argument& e) 
    {
        ERRORLOG("GetProposal duration string to double error");
        ack_t.code = -101;
        ack_t.message = "duration string to double error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    
    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    req_t.gastrade.first = remove0xPrefix(req_t.gastrade.first);
    req_t.gastrade.second = remove0xPrefix(req_t.gastrade.second);

    uint64_t  beginTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
    uint64_t  endTime = beginTime + time * 3600 * 1000000; 

    std::regex pattern2("^[1-9]\\d*$"); 
    if(!std::regex_match(req_t.minVoteNum, pattern2))
    {
        ERRORLOG("Input minVoteNum error");
        ack_t.code = -102;
        ack_t.message = "Input minVoteNum error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    uint64_t minVote = std::stoull(req_t.minVoteNum);

    ReplaceCreateProposalTransaction(fromAddr, req_t.gastrade, req_t.Identifier, req_t.title, beginTime, endTime, req_t.assetName, req_t.exchangeRate, remove0xPrefix(req_t.contractAddr), minVote, isFindUtxoFlag, encodedInfo, &ack_t);

    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetRevokeProposal(const Request & req, Response & res)
{
    getRevokeProposalReq req_t;
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateRevokeProposalTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    const std::regex pattern(R"(-?\d+(\.\d)?\b)");
    if (!std::regex_match(req_t.duration, pattern))
    {
        ERRORLOG("GetProposal input duration error");
        ack_t.code = -100;
        ack_t.message = "input duration error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    double time = 0;
    try 
    {
        time = std::stod(req_t.duration);
    } 
    catch (const std::invalid_argument& e) 
    {
        ERRORLOG("GetProposal duration string to double error");
        ack_t.code = -101;
        ack_t.message = "duration string to double error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    req_t.gastrade.first = remove0xPrefix(req_t.gastrade.first);
    req_t.gastrade.second = remove0xPrefix(req_t.gastrade.second);
    uint64_t  beginTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
    uint64_t  endTime = beginTime + time * 3600 * 1000000; 

    std::regex pattern2("^[1-9]\\d*$"); 
    if(!std::regex_match(req_t.minVoteNum, pattern2))
    {
        ERRORLOG("Input minVoteNum error");
        ack_t.code = -102;
        ack_t.message = "Input minVoteNum error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    uint64_t minVote = std::stoull(req_t.minVoteNum);

    if(minVote < 1)
    {
        ERRORLOG("minVote mest more then 1, minVote:{}", minVote);
        ack_t.code = -103;
        ack_t.message = "minVote mest more then 1";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    ReplaceCreateRevokeProposalTransaction(fromAddr, req_t.gastrade, beginTime, endTime, remove0xPrefix(req_t.proposalHash), minVote, isFindUtxoFlag, encodedInfo, &ack_t);
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetVote(const Request & req, Response & res)
{
    getVoteReq req_t; 
    txAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateVoteTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    int32_t pollType = std::stoll(req_t.pollType);
    global::ca::TxType voteTxType = (global::ca::TxType)std::stoll(req_t.voteTxType);

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodedInfo = Base64Encode(req_t.txInfo);
    req_t.gastrade.first = remove0xPrefix(req_t.gastrade.first);
    req_t.gastrade.second = remove0xPrefix(req_t.gastrade.second);

    ReplaceCreateVoteTransaction(fromAddr, req_t.gastrade, remove0xPrefix(req_t.voteHash), pollType, voteTxType, isFindUtxoFlag, encodedInfo, &ack_t);
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetFund(const Request & req, Response & res){
    getFundReq req_t;
    txAck ack_t;
    
    VALIDATE_JSON_REQUEST_PARSING
    std::string fromAddr = remove0xPrefix(req_t.fromAddr);
    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "CreateFundTransaction";
    ack_t.sleeptime = req_t.sleeptime;

    bool isFindUtxoFlag = req_t.isFindUtxo;
    std::string encodeInfo = Base64Encode(req_t.txInfo);
    
    //comment: encodeInfo doesn't use
    ReplaceCreateFundTransaction(fromAddr,encodeInfo,&ack_t);
    res.set_content(ack_t._parseToString(),"application/json");
}

void _ApiGetAssetType(const Request & req, Response & res)
{
    getAssetTypeReq req_t;
    getAssetTypeAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    DBReader db;

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetAllAssetType";
    ack_t.code = 0;
    ack_t.message = "success";
    auto dbRet = db.GetAllAssetType(ack_t.assertType);
    if(DBStatus::DB_SUCCESS != dbRet)
    {
        ack_t.code = -1;
        ack_t.message = "Get asset type error";
    }
    for(auto & i: ack_t.assertType)
    {
        i = addHexPrefix(i);
    }

    res.set_content(ack_t._parseToString(), "application/json");
}

void _ApiGetAssetTypeInfo(const Request & req, Response & res)
{
    getAssetTypeInfoReq req_t;
    getAssetTypeInfoAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetAssetTypeInfo";
    ack_t.code = 0;
    ack_t.message = "success";
    DBReader dbReader;

    std::string info;
    auto dbRet = dbReader.GetAssetInfobyAssetType(remove0xPrefix(req_t.assetType), info);
    if(DBStatus::DB_SUCCESS != dbRet)
    {
        ack_t.code = -1;
        ack_t.message = "Get asset info error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    Base64 base;
    ack_t.proposalInfo = base.Decode(info.c_str(), info.size());

    try
    {
        nlohmann::json proposalInfo = nlohmann::json::parse(ack_t.proposalInfo);
        std::string interimContractAddress = proposalInfo["ContractAddr"];
        proposalInfo["ContractAddr"] = addHexPrefix(interimContractAddress);
        ack_t.proposalInfo = proposalInfo.dump();
    }
    catch(const std::exception& e)
    {
        std::cerr << e.what() << '\n';
    }
    
    
    std::vector<std::string> revokeTxHashs;
    dbRet = dbReader.GetRevokeTxHashByAssetType(remove0xPrefix(req_t.assetType), revokeTxHashs);
    if(dbRet == DBStatus::DB_NOT_FOUND)
    {
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    else if(dbRet != DBStatus::DB_SUCCESS)
    {
        ERRORLOG("GetRevokeTxHashByAssetType error, error num: {}", dbRet);
        ack_t.code = -2;
        ack_t.message = "Get revoke tx hash error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    for(const auto& t: revokeTxHashs)
    {
        std::string revokeInfo;
        dbRet = dbReader.GetRevokeProposalInfobyTxHash(t, revokeInfo);
        if(DBStatus::DB_SUCCESS != dbRet)
        {
            ERRORLOG("GetRevokeProposalInfobyTxHash error, error num: {}", dbRet);
            ack_t.code = -3;
            ack_t.message = "Get revoke proposal info error";
            res.set_content(ack_t._parseToString(), "application/json");
            return;
        }
        std::string decode = base.Decode(revokeInfo.c_str(), revokeInfo.size());
        nlohmann::json dataJson = nlohmann::json::parse(decode);
        dataJson["RevokeProposalHash"] = addHexPrefix(t);
        try
        {
            std::string tmpProposalHash = dataJson["ProposalHash"];
            dataJson["ProposalHash"] = addHexPrefix(tmpProposalHash);
        }
        catch(const std::exception& e)
        {
            std::cerr << e.what() << '\n';
        }

        ack_t.revokeProposalInfo.emplace_back(dataJson.dump());
    }
    res.set_content(ack_t._parseToString(), "application/json");
}

void _ApiGetVoteAddrsByHash(const Request &req, Response &res)
{
    getVoteAddrsReq req_t;
    getVoteAddrsAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetVoteAddrs";
    ack_t.code = 0;
    ack_t.message = "success";
    DBReader db;

    if (remove0xPrefix(req_t.hash).size() != 64)
    {
        ERRORLOG("GetApproveAddrsByAssetHash error, Asset Hash length error hash is{}", req_t.hash);
        ack_t.code = -1;
        ack_t.message = "Asset Hash length error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }
    auto dbRet = db.GetApproveAddrsByAssetHash(remove0xPrefix(req_t.hash), ack_t.approveAddrs);
    if (DBStatus::DB_SUCCESS != dbRet && DBStatus::DB_NOT_FOUND != dbRet)
    {
        ERRORLOG("GetApproveAddrsByAssetHash error, error num: {}", dbRet);
        ack_t.code = -2;
        ack_t.message = "Get approve addrs error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    std::set<std::string> modifiedApproveAddrs;
    for (const auto &addr : ack_t.approveAddrs)
    {
        modifiedApproveAddrs.insert(addHexPrefix(addr));
    }
    ack_t.approveAddrs = std::move(modifiedApproveAddrs);

    dbRet = db.GetAgainstAddrsByAssetHash(req_t.hash, ack_t.againstAddrs);
    if (DBStatus::DB_SUCCESS != dbRet && DBStatus::DB_NOT_FOUND != dbRet)
    {
        ERRORLOG("GetAgainstAddrsByAssetHash error, error num: {}", dbRet);
        ack_t.code = -3;
        ack_t.message = "Get against addrs error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    std::set<std::string> modifiedAgainstAddrs;
    for (const auto &addr : ack_t.againstAddrs)
    {
        modifiedAgainstAddrs.insert(addHexPrefix(addr));
    }
    ack_t.againstAddrs = std::move(modifiedAgainstAddrs);

    res.set_content(ack_t._parseToString(), "application/json");
}

void _ApiGetVoteTxHashByAssetType(const Request & req, Response & res)
{
    getVoteTxHashAck ack_t;
    getVoteTxHashReq req_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetVoteTxHash";
    ack_t.code = 0;
    ack_t.message = "success";

    DBReader dbReader;
    if (DBStatus::DB_SUCCESS != dbReader.GetVoteTxHashByAssetHash(remove0xPrefix(req_t.hash), ack_t.txHashs))
    {
        ack_t.code = -1;
        ack_t.message = "Get vote tx hash error";
    }
    for(auto & i: ack_t.txHashs)
    {
        i = addHexPrefix(i);
    }
    res.set_content(ack_t._parseToString(), "application/json");
}

void _GetAddrType(const Request &req, Response &res)
{
    getAddrTypeReq req_t;
    getAddrTypeAck ack_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetAddrType";
    ack_t.code = 0;
    ack_t.message = "success";

    std::string addr = remove0xPrefix(req_t.addr);

    DBReader dbReader;
    std::vector<std::string> utxos;
    DBStatus::DB_SUCCESS == dbReader.GetLockAddressUtxo(addr, global::ca::ballotAssetType, utxos) ? ack_t.isLocked = true : ack_t.isLocked = false;


    utxos.clear();
    std::string assetType;
    int ret = ca_algorithm::GetCanBeRevokeAssetType(assetType);
    if(ret != 0)
    {
        ack_t.isStaked = false;
    }
    else 
    {
        DBStatus::DB_SUCCESS == dbReader.FetchStakeUtxos(addr, assetType, utxos) ? ack_t.isStaked = true : ack_t.isStaked = false;
    }
    

    utxos.clear();
    DBStatus::DB_SUCCESS == dbReader.GetBonusAddrAndAssetTypeByDelegatingAddr(addr, utxos) ? ack_t.isDelegated = true : ack_t.isDelegated = false;

    uint64_t curTime = MagicSingleton<TimeUtil>::GetInstance()->GetUTCTimestamp();
    std::map<std::string, uint64_t> companyDividend;
    ret = ca_algorithm::CalcBonusValue(curTime, addr, companyDividend);
    if(ret != 0)
    {
        ack_t.isBonus = false;
        ack_t.isQualified = false;
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

	ret = check_node_validity(addr);
	if(ret != 0)
	{
        ack_t.isBonus = false;
        ack_t.isQualified = false;
        res.set_content(ack_t._parseToString(), "application/json");
        return;
	}

	ret = CheckBonusQualification(addr, curTime);
    ret == 0 ? ack_t.isBonus = true : ack_t.isBonus = false;

    ack_t.isQualified = true;

    res.set_content(ack_t._parseToString(), "application/json");
}
void _GetBonusAddrByDelegatingAddr(const Request &req, Response &res)
{
    getBonusAddrByDelegateAddrAck ack_t;
    getBonusAddrByDelegateAddrReq req_t;
    VALIDATE_JSON_REQUEST_PARSING

    ack_t.id = req_t.id;
    ack_t.jsonrpc = req_t.jsonrpc;
    ack_t.method = "GetBonusAddrByDelegatingAddr";
    ack_t.code = 0;
    ack_t.message = "success"; 

    std::string addr = remove0xPrefix(req_t.addr);

    DBReader dbReader;
    std::vector<std::string> bonusAddr;
    if(DBStatus::DB_SUCCESS != dbReader.GetBonusAddrAndAssetTypeByDelegatingAddr(addr, bonusAddr))
    {
        ack_t.code = -1;
        ack_t.message = "Get bonus addr error";
        res.set_content(ack_t._parseToString(), "application/json");
        return;
    }

    for(auto & bonus: bonusAddr)
    {
        std::vector<std::string> addrAndAssetType;
        StringUtil::SplitString(bonus, "-", addrAndAssetType);
        if(addrAndAssetType.size() != 2)
        {
            ack_t.code = -2;
            ack_t.message = "Get assetType error";
            res.set_content(ack_t._parseToString(), "application/json");
            return;
        }
        ack_t.bonusAddr = addHexPrefix(addrAndAssetType.at(0));
        ack_t.assetType = addHexPrefix(addrAndAssetType.at(1));
    }

    res.set_content(ack_t._parseToString(), "application/json");
}

struct CPUStat 
{
    unsigned long long user;
    unsigned long long nice;
    unsigned long long system;
    unsigned long long idle;
    unsigned long long iowait;
    unsigned long long irq;
    unsigned long long softirq;
};

static std::vector<CPUStat> GetCpuStats() {
    std::vector<CPUStat> cpuStats;
    std::ifstream statFile("/proc/stat");

    std::string line;
    while (std::getline(statFile, line)) 
    {
        if (line.compare(0, 3, "cpu") == 0) 
        {
            std::istringstream ss(line);

            std::string cpuLabel;
            CPUStat stat;
            ss >> cpuLabel >> stat.user >> stat.nice >> stat.system >>
                stat.idle >> stat.iowait >> stat.irq >> stat.softirq;

            cpuStats.push_back(stat);
        }
    }

    return cpuStats;
}

static double CalculateCpuUsage(const CPUStat &prev, const CPUStat &curr) 
{
    auto prevTotal = prev.user + prev.nice + prev.system + prev.idle +
                      prev.iowait + prev.irq + prev.softirq;
    auto currTotal = curr.user + curr.nice + curr.system + curr.idle +
                      curr.iowait + curr.irq + curr.softirq;

    auto totalDiff = currTotal - prevTotal;
    auto idleDiff = curr.idle - prev.idle;

    return (totalDiff - idleDiff) * 100.0 / totalDiff;
}

static std::string doubleToString(double value, int precision) 
{
    std::ostringstream out;
    out << std::fixed << std::setprecision(precision) << value;
    return out.str();
}

// get cpu info
std::string getCpuInfo() 
{
    std::string sum;
    sum =
        "======================================================================"
        "=========";
    sum += "\n";
    sum += "get_cpu_info";
    sum += "\n";
    std::ifstream cpuinfoFile("/proc/cpuinfo");
    std::string line;
    int cpuCores = 0;
    std::string cpuModel;
    double cpuFrequency = 0;

    while (std::getline(cpuinfoFile, line)) 
    {
        if (line.compare(0, 9, "processor") == 0) 
        {
            cpuCores++;
        } else if (line.compare(0, 10, "model name") == 0) 
        {
            cpuModel = line.substr(line.find(":") + 2);
        } else if (line.compare(0, 7, "cpu MHz") == 0) 
        {
            cpuFrequency = std::stod(line.substr(line.find(":") + 2)) / 1000;
        }
    }

    auto prevStats = GetCpuStats();

    std::this_thread::sleep_for(std::chrono::seconds(1));
    auto currStats = GetCpuStats();

    double totalUsage = 0;
    for (size_t i = 1; i < prevStats.size(); ++i) {
        totalUsage += CalculateCpuUsage(prevStats[i], currStats[i]);
    }

    double avgUsage = totalUsage / (prevStats.size() - 1);
    sum +=
        "CPU Usage: " + doubleToString(avgUsage, 1) + "%" + "\n";
    sum += "CPU Frequency: " + doubleToString(cpuFrequency, 3) +
           " GHZ" + "\n";
    sum += "CPU Model: " + cpuModel + "\n";
    sum += "CPU Cores: " + std::to_string(cpuCores);
    return sum;
}


struct NetStat 
{
    unsigned long long bytesReceived;
    unsigned long long bytesSent;
};

static NetStat GetNetStat(const std::string &interface) {
    NetStat netStat = {0, 0};
    std::ifstream netDevFile("/proc/net/dev");
    std::string line;

    while (std::getline(netDevFile, line)) 
    {
        if (line.find(interface) != std::string::npos) 
        {
            std::istringstream ss(line);
            std::string iface;
            ss >> iface >> netStat.bytesReceived;

            for (int i = 0; i < 7; ++i) 
            {
                unsigned long long tmp;
                ss >> tmp;
            }

            ss >> netStat.bytesSent;
            break;
        }
    }

    return netStat;
}

static std::string formatSpeed(double speed) 
{
    std::stringstream ss;
    ss << std::fixed << std::setprecision(2) << speed << " Mbps";
    return ss.str();
}


static std::string GetMacAddress(const std::string &interface) 
{
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) 
    {
        return "";
    }

    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, interface.c_str(), IFNAMSIZ - 1);

    if (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) 
    {
        close(sock);
        return "";
    }

    close(sock);
    char macAddress[18];
    snprintf(macAddress, sizeof(macAddress), "%02x:%02x:%02x:%02x:%02x:%02x",
             static_cast<unsigned char>(ifr.ifr_hwaddr.sa_data[0]),
             static_cast<unsigned char>(ifr.ifr_hwaddr.sa_data[1]),
             static_cast<unsigned char>(ifr.ifr_hwaddr.sa_data[2]),
             static_cast<unsigned char>(ifr.ifr_hwaddr.sa_data[3]),
             static_cast<unsigned char>(ifr.ifr_hwaddr.sa_data[4]),
             static_cast<unsigned char>(ifr.ifr_hwaddr.sa_data[5]));

    return macAddress;
}

static std::string networkModel(const std::string &interface) 
{
    std::string modelPath = "/sys/class/net/" + interface + "/device/modalias";
    std::ifstream modelFile(modelPath);
    if (!modelFile.is_open()) 
    {
        return "";
    }

    std::string modelInfo;
    std::getline(modelFile, modelInfo);
    modelFile.close();

    return modelInfo;
}

std::string GetNetRate() 
{
    std::string interface = "eth0";
    auto prevStat = GetNetStat(interface);
    std::string str;
    str =
        "======================================================================"
        "=========";
    str += "\n";
    str += "GetNetRate";
    str += "\n";
    std::this_thread::sleep_for(std::chrono::seconds(1));
    auto currStat = GetNetStat(interface);

    double downloadSpeed =
        (currStat.bytesReceived - prevStat.bytesReceived) * 8 / 1000.0 /
        1000.0;
    double uploadSpeed =
        (currStat.bytesSent - prevStat.bytesSent) * 8 / 1000.0 / 1000.0;

    std::string downloadSpeedStr = formatSpeed(downloadSpeed);
    std::string uploadSpeedStr = formatSpeed(uploadSpeed);

    str += "Download speed: " + downloadSpeedStr + "\n";
    str += "Upload speed: " + uploadSpeedStr + "\n";
    str += "Interface: " + interface + "\n";
    str += "MAC Address: " + GetMacAddress(interface);
    str += "Model Info: " + networkModel(interface);
    prevStat = currStat;
    return str;
}

std::string Exec(const char *cmd) 
{
    char buffer[128];
    std::string result = "";
    FILE *pipe = popen(cmd, "r");
    if (!pipe)
        throw std::runtime_error("popen() failed!");
    try {
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            result += buffer;
        }
    } catch (...) {
        pclose(pipe);
        throw;
    }
    pclose(pipe);
    return result;
}


static std::string GetOsVersion() 
{
    struct utsname buffer;
    std::string osRelease = Exec("cat /etc/os-release");
    std::string str;
    if (uname(&buffer) != 0) {
        return "Error getting OS version";
    }
    str = std::string(buffer.sysname) + " " + std::string(buffer.release) +
          " " + std::string(buffer.version);
    str += osRelease;
    return str;
}

std::string ApiGetSystemInfo() 
{
    std::string str;
    str =
        "======================================================================"
        "=========";
    str += "\n";
    str += "ApiGetSystemInfo";
    str += "\n";
    str += "OS Version: " + GetOsVersion() + "\n";
    return str;
}

std::string ApiTime()
{
    std::string str;
	auto now = std::time(0);
    str += std::ctime(&now);	
   	auto now1 = std::chrono::system_clock::now();
    auto nowUs = std::chrono::duration_cast<std::chrono::microseconds>(now1.time_since_epoch()).count();
    auto stamp= std::to_string(nowUs) ;
    str  += stamp +"\n";

    addrinfo hints;
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE;

    addrinfo *result;
    getaddrinfo(NULL, "0", &hints, &result);

    auto timeMs = std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
    std::string netTime = std::to_string(timeMs) ; 
    str += netTime + "\n";

    if(timeMs >1000 + nowUs)
    {
        std::string cache = std::to_string(timeMs - nowUs); 
        str +=cache +"microsecond"+"slow" + "\n" ;
    }

    if(nowUs  > 1000 + timeMs)
    {
        std::string cache = std::to_string(timeMs - nowUs);
        str +=cache +"microsecond"+"fast" +"\n";
    }
    else 
    {
        str +="normal";
        str +="\n";
    }
    str +="time check======================" ;
    str +="\n";
    return str;
}


std::string GetProcessInfo() 
{
    const int BUFFER_SIZE = 1024;

    std::string str;
    str =
        "======================================================================"
        "=========";
    str += "\n";
    str += "GetProcessInfo";
    str += "\n";

    FILE *pipe = popen("ps -ef", "r");
    if (!pipe) {

        return "-1";
    }
    
    char buffer[BUFFER_SIZE];
    while (fgets(buffer, BUFFER_SIZE, pipe)) 
    {

        str += buffer;
        str += "\n";
    }
    pclose(pipe);
    return str;
}

int GetFileLine() 
{
    FILE *fp;
    int flag = 0, count = 0;
    if ((fp = fopen("/proc/meminfo", "r")) == NULL)
        return -1;
    while (!feof(fp)) 
    {
        flag = fgetc(fp);
        if (flag == '\n')
            count++;
    }
    fclose(fp);
    return count;
}

void GetMemOccupy(int lenNum, std::string &strMem) 
{
    strMem = "";
    FILE *fpMemInfo = fopen("/proc/meminfo", "r");
    if (NULL == fpMemInfo) 
    {
        strMem = "-1 meminfo fopen error";
        return;
    }

    int i = 0;
    int value = 0;
    char name[512];
    char line[512];
    int nFiledNumber = 2;
    int total = 0;
    int available = 0;
    while (fgets(line, sizeof(line) - 1, fpMemInfo)) 
    {
        if (sscanf(line, "%s%u", name, &value) != nFiledNumber) 
        {
            continue;
        }
        if (0 == strcmp(name, "MemTotal:")) 
        {
            total = value;
            strMem += "MemTotal:\t" + std::to_string(value) + '\n';
        } 
        else if (0 == strcmp(name, "MemFree:")) 
        {
            strMem += "MemFree:\t" + std::to_string(value) + '\n';
        } 
        else if (0 == strcmp(name, "MemAvailable:")) 
        {
            available = value;
            strMem += "MemAvailable:\t" + std::to_string(value) + '\n';
        } 
        else if (0 == strcmp(name, "Buffers:")) 
        {
            strMem += "MemBuffers:\t" + std::to_string(value) + '\n';
        } 
        else if (0 == strcmp(name, "Cached:")) 
        {
            strMem += "MemCached:\t" + std::to_string(value) + '\n';
        }
        else if (0 == strcmp(name, "SwapCached:")) 
        {
            strMem += "SwapCached:\t" + std::to_string(value) + '\n';
        } 
        else if (0 == strcmp(name, "SwapTotal:")) 
        {
            strMem += "SwapTotal:\t" + std::to_string(value) + '\n';
        } 
        else if (0 == strcmp(name, "SwapFree:")) 
        {
            strMem += "SwapFree:\t" + std::to_string(value) + '\n';
        }

        if (++i == lenNum) 
        {
            break;
        }
    }
    strMem += "Memory usage:\t" +
              std::to_string(100.0 * (total - available) / total) + "%\n";
    fclose(fpMemInfo);
}

void GetDiskType(std::string &strMem) {
    std::ifstream rotational("/sys/block/sda/queue/rotational");
    if (rotational.is_open()) {
        int isRotational;
        rotational >> isRotational;
        strMem += "Disk type:\t";
        strMem += (isRotational ? "HDD" : "SSD");
        rotational.close();
    } 
    else 
    {
        strMem += "-1 Disk rotational open error";
    }
}

void _GetAllSystemInfo(const Request &req, Response &res) 
{
    std::string outPut;
    std::string MemStr;
    int lenNum = GetFileLine();
    GetMemOccupy(lenNum, MemStr);
    GetDiskType(MemStr);
    outPut =
        "=================================================================="
        "=============";
    outPut += "\n";
    outPut += "GetMemOccupy";
    outPut += MemStr;
    outPut += "\n";

    outPut += getCpuInfo() + "\n";
    outPut += GetNetRate() + "\n";
    outPut += ApiGetSystemInfo() + "\n";
    outPut += ApiTime() + "\n";
    outPut += GetProcessInfo() + "\n";
    

    res.set_content(outPut, "text/plain");
}
